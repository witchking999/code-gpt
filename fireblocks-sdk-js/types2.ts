/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/vault/accounts": {
    /**
     * List vault accounts
     * @description Gets all vault accounts in your workspace.
     */
    get: {
      parameters: {
        query?: {
          namePrefix?: string;
          nameSuffix?: string;
          minAmountThreshold?: number;
          assetId?: string;
        };
      };
      responses: {
        /** @description A list of vault accounts */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAccount"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create a new vault account
     * @description Creates a new vault account with the requested name.
     */
    post: {
      requestBody: {
        content: {
          "application/json": {
            /** @description Account Name */
            name?: string;
            /** @description Optional - if true, the created account and all related transactions will not be shown on Fireblocks console */
            hiddenOnUI?: boolean;
            /** @description Optional - Sets a customer reference ID */
            customerRefId?: string;
            /** @description Optional - Sets the autoFuel property of the vault account */
            autoFuel?: boolean;
          };
        };
      };
      responses: {
        /** @description A Vault Account object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAccount"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/bulk": {
    /**
     * Create new vault accounts in bulk
     * @description Start an offline job to create multiple vault accounts
     */
    post: {
      requestBody: {
        content: {
          "application/json": {
            /** @description Count */
            count?: number;
            /** @description Array of asset IDs */
            assetIds?: string[];
          };
        };
      };
      responses: {
        /** @description A JobCreated object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["JobCreated"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts_paged": {
    /**
     * List vault accounts (Paginated)
     * @description Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
     */
    get: {
      parameters: {
        query?: {
          namePrefix?: string;
          nameSuffix?: string;
          /** @description Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts. */
          minAmountThreshold?: number;
          assetId?: string;
          orderBy?: "ASC" | "DESC";
          before?: string;
          after?: string;
          limit?: number;
        };
      };
      responses: {
        /** @description A VaultAccountsPagedResponse object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAccountsPagedResponse"];
          };
        };
      };
    };
  };
  "/vault/accounts/{vaultAccountId}": {
    /**
     * Find a vault account by ID
     * @description Returns the requested vault account.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the vault account to return type: string */
          vaultAccountId: string;
        };
      };
      responses: {
        /** @description A Vault Account object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAccount"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Rename a vault account
     * @description Renames the requested vault account.
     */
    put: {
      parameters: {
        path: {
          /** @description The ID of the vault account to edit */
          vaultAccountId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Account Name */
            name?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/asset_wallets": {
    /**
     * List asset wallets (Paginated)
     * @description Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances.
     * **Note:**
     *   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting).
     */
    get: {
      parameters: {
        query?: {
          /** @description When specified, only asset wallets with total balance larger than this amount are returned. */
          totalAmountLargerThan?: number;
          /** @description When specified, only asset wallets cross vault accounts that have this asset ID are returned. */
          assetId?: string;
          orderBy?: "ASC" | "DESC";
          /** @description Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page. */
          before?: string;
          /** @description Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page. */
          after?: string;
          /** @description The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000. */
          limit?: number;
        };
      };
      responses: {
        /** @description A PaginatedAssetWalletResponse object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["PaginatedAssetWalletResponse"];
          };
        };
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/hide": {
    /**
     * Hide a vault account in the console
     * @description Hides the requested vault account from the web console view.
     */
    post: {
      parameters: {
        path: {
          /** @description The vault account to hide */
          vaultAccountId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/unhide": {
    /**
     * Unhide a vault account in the console
     * @description Makes a hidden vault account visible in web console view.
     */
    post: {
      parameters: {
        path: {
          /** @description The vault account to unhide */
          vaultAccountId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/activate": {
    /**
     * Activate a wallet in a vault account.
     * @description Initiates activation for a wallet in a vault account. Activation is required for tokens that need an on-chain transaction for creation (XLM tokens, SOL tokens etc).
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the vault account to return, or 'default' for the default vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      responses: {
        /** @description OK */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["CreateVaultAssetResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/set_customer_ref_id": {
    /**
     * Set an AML/KYT customer reference ID for a vault account
     * @description Assigns an AML/KYT customer reference ID for the vault account.
     */
    post: {
      parameters: {
        path: {
          /** @description The vault account ID */
          vaultAccountId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Customer reference ID */
            customerRefId?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/set_auto_fuel": {
    /**
     * Turn autofueling on or off
     * @description Sets the autofueling property of the vault account to enabled or disabled.
     */
    post: {
      parameters: {
        path: {
          /** @description The vault account ID */
          vaultAccountId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Auto Fuel */
            autoFuel?: boolean;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}": {
    /**
     * Get the asset balance for a vault account
     * @description Returns a wallet for a specific asset of a vault account.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the vault account to return */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      responses: {
        /** @description A VaultAsset object */
        200: {
          content: {
            "*/*": components["schemas"]["VaultAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create a new wallet
     * @description Creates a wallet for a specific asset in a vault account.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the vault account to return, or 'default' for the default vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            /** @description Optional - when creating an EOS wallet, the account name. If not provided, a random name will be generated */
            eosAccountName?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["CreateVaultAssetResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/balance": {
    /**
     * Refresh asset balance data
     * @description Updates the balance of a specific asset in a vault account.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the vault account to return */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      requestBody?: {
        content: {
          "*/*": Record<string, never>;
        };
      };
      responses: {
        /** @description A VaultAsset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/addresses": {
    /**
     * Get asset addresses
     * @description Lists all addresses for specific asset of vault account. </br>
     * - **This endpoint will be deprecated on Mar 31, 2024.**
     * - If your application logic or scripts rely on the deprecated endpoint, you should update to account for `GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated` before Mar 31, 2024.
     * - All workspaces created after Mar 31, 2024. will have it disabled. If it is disabled for your workspace and you attempt to use it, you will receive the following error message: 'This endpoint is unavailable.'
     * - Please use the `GET/V1/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated endpoint` to return all the wallet addresses associated with the specified vault account and asset in a paginated list.
     * - This API call is subject to rate limits.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the vault account to return */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      responses: {
        /** @description A list of deposit addresses */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultWalletAddress"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create new asset deposit address
     * @description Creates a new deposit address for an asset of a vault account.
     */
    post: operations["createVaultAccountAssetAddress"];
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated": {
    /**
     * List addresses (Paginated)
     * @description Returns a paginated response of the addresses for a given vault account and asset.
     */
    get: {
      parameters: {
        query?: {
          limit?: number;
          before?: string;
          after?: string;
        };
        path: {
          vaultAccountId: string;
          assetId: string;
        };
      };
      responses: {
        /** @description A list of wallet's addresses */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultWalletAddress"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount": {
    /**
     * Get the maximum spendable amount in a single transaction.
     * @description Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
     */
    get: {
      parameters: {
        query?: {
          /** @description False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device. */
          manualSignging?: boolean;
        };
        path: {
          /** @description The ID of the vault account, or 'default' for the default vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      responses: {
        /** @description OK */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}": {
    /**
     * Update address description
     * @description Updates the description of an existing address of an asset in a vault account.
     */
    put: {
      parameters: {
        path: {
          /** @description The ID of the vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
          /** @description The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address */
          addressId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            /** @description The address description */
            description?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id": {
    /**
     * Assign AML customer reference ID
     * @description Sets an AML/KYT customer reference ID for a specific address.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
          /** @description The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address */
          addressId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Customer reference ID */
            customerRefId?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy": {
    /**
     * Convert a segwit address to legacy format
     * @description Converts an existing segwit address to the legacy format.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
          /** @description The segwit address to translate */
          addressId: string;
        };
      };
      responses: {
        /** @description The created address */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["CreateAddressResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs": {
    /**
     * Get UTXO unspent inputs information
     * @description Returns unspent inputs information of an asset in a vault account.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the vault account */
          vaultAccountId: string;
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      responses: {
        /** @description List of Unspent information per input */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnspentInputsResponse"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/public_key_info/": {
    /**
     * Get the public key information
     * @description Gets the public key information based on derivation path and signing algorithm.
     */
    get: {
      parameters: {
        query: {
          derivationPath: string;
          algorithm: string;
          compressed?: boolean;
        };
      };
      responses: {
        /** @description Public key information */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["PublicKeyInformation"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info": {
    /**
     * Get the public key for a vault account
     * @description Gets the public key information for the vault account.
     */
    get: {
      parameters: {
        query?: {
          compressed?: boolean;
        };
        path: {
          /** @description The ID of the vault account */
          vaultAccountId: string;
          /** @description The ID of the asset. */
          assetId: string;
          /** @description Whether the address should be derived internal (change) or not. */
          change: number;
          /** @description The index of the address for the derivation path. */
          addressIndex: number;
        };
      };
      responses: {
        /** @description Public Key Information */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["PublicKeyInformation"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/assets": {
    /**
     * Get asset balance for chosen assets
     * @description Gets the assets amount summary for all accounts or filtered accounts.
     */
    get: {
      parameters: {
        query?: {
          accountNamePrefix?: string;
          accountNameSuffix?: string;
        };
      };
      responses: {
        /** @description Amount by asset */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAsset"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/assets/bulk": {
    /**
     * Create new wallets in bulk
     * @description Start an offline job to create multiple wallets for given vault accounts
     */
    post: {
      requestBody: {
        content: {
          "application/json": {
            /** @description ID of new asset */
            assetId?: string;
            /** @description lowest vault account ID of range */
            vaultAccountIdFrom?: string;
            /** @description highest vault account ID in range */
            vaultAccountIdTo?: string;
          };
        };
      };
      responses: {
        /** @description A JobCreated object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["JobCreated"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/vault/assets/{assetId}": {
    /**
     * Get vault balance by asset
     * @description Gets the vault balance summary for an asset.
     */
    get: {
      parameters: {
        path: {
          assetId: string;
        };
      };
      responses: {
        /** @description Vault amount by asset */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["VaultAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/staking/chains": {
    /**
     * List staking supported chains
     * @description Return an alphabetical list of supported chains.
     */
    get: operations["getChains"];
  };
  "/staking/chains/{chainDescriptor}/chainInfo": {
    /**
     * Get chain-specific staking summary
     * @description Return chain-specific, staking-related information summary (e.g. epoch
     * details, lockup durations, estimated rewards, etc.).
     */
    get: operations["getChainInfo"];
  };
  "/staking/chains/{chainDescriptor}/{actionId}": {
    /**
     * Execute a staking action
     * @description Perform a chain-specific staking action (e.g. stake, unstake, withdraw).
     */
    post: operations["executeAction"];
  };
  "/staking/positions": {
    /**
     * List staking positions details
     * @description Return detailed information on all staking positions, including the
     * staked amount, rewards, status and more.
     */
    get: operations["getAllDelegations"];
  };
  "/staking/positions/summary": {
    /**
     * Get staking summary details
     * @description Return a summary of all vaults, categorized by their status (active,
     * inactive), the total amounts staked and total rewards per-chain.
     */
    get: operations["getSummary"];
  };
  "/staking/positions/summary/vaults": {
    /**
     * Get staking summary details by vault
     * @description Return a summary for each vault, categorized by their status (active,
     * inactive), the total amounts staked and total rewards per-chain.
     */
    get: operations["getSummaryByVault"];
  };
  "/staking/positions/{id}": {
    /**
     * Get staking position details
     * @description Return detailed information on a staking position, including the staked
     * amount, rewards, status and more.
     */
    get: operations["getDelegationById"];
  };
  "/staking/providers": {
    /**
     * List staking providers details
     * @description Return information on all the available staking providers.
     */
    get: operations["getProviders"];
  };
  "/staking/providers/{providerId}/approveTermsOfService": {
    /**
     * Approve staking terms of service
     * @description Approve the terms of service of the staking provider. This must be called before performing a staking action for the first
     * time with this provider.
     */
    post: operations["approveTermsOfServiceByProviderId"];
  };
  "/exchange_accounts": {
    /**
     * List exchange accounts
     * @description Returns all exchange accounts. </br> **Note:** This endpoint will be deprecated soon. Please use the `/exchange_accounts/paged` endpoint instead.
     */
    get: {
      responses: {
        /** @description An ExchangeAccount object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExchangeAccount"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/exchange_accounts/paged": {
    /**
     * List exchange accounts (paged)
     * @description Returns a paginated list of exchange accounts.
     */
    get: {
      parameters: {
        query: {
          before?: string;
          after?: string;
          /** @description number of exchanges per page */
          limit: number;
        };
      };
      responses: {
        /** @description An ExchangeAccount object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExchangeAccountsPaged"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/exchange_accounts/{exchangeAccountId}": {
    /**
     * Find a specific exchange account
     * @description Returns an exchange account by ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the exchange account to return */
          exchangeAccountId: string;
        };
      };
      responses: {
        /** @description An ExchangeAccount object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExchangeAccount"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/exchange_accounts/{exchangeAccountId}/internal_transfer": {
    /**
     * Internal tranfer for exchange accounts
     * @description Transfers funds between trading accounts under the same exchange account.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the exchange account to return */
          exchangeAccountId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            asset?: string;
            amount?: string;
            sourceType?: components["schemas"]["TradingAccountType"];
            destType?: components["schemas"]["TradingAccountType"];
          };
        };
      };
      responses: {
        /** @description Transfer succeeded */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/exchange_accounts/{exchangeAccountId}/convert": {
    /** Convert exchange account funds from the source asset to the destination asset. Coinbase (USD to USDC, USDC to USD) and Bitso (MXN to USD) are supported conversions. */
    post: {
      parameters: {
        path: {
          /** @description The ID of the exchange account. Please make sure the exchange supports conversions. To find the ID of your exchange account, use GET/exchange_accounts. */
          exchangeAccountId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            /** @description Name of the source asset (must be in a currency that is supported for conversions in the selected exchange type that corresponds to your exchange ID) */
            srcAsset: string;
            /** @description Name of the destination asset (must be in a currency that is supported for conversions in the selected exchange type that corresponds to your exchange ID) */
            destAsset: string;
            /** @description The amount to transfer (in the currency of the source asset) */
            amount: number;
          };
        };
      };
      responses: {
        /** @description Conversion successful */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/exchange_accounts/{exchangeAccountId}/{assetId}": {
    /**
     * Find an asset for an exchange account
     * @description Returns an asset for an exchange account.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the exchange account to return */
          exchangeAccountId: string;
          /** @description The ID of the asset to return */
          assetId: string;
        };
      };
      responses: {
        /** @description An ExchangeAccountAsset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExchangeAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/fiat_accounts": {
    /**
     * List fiat accounts
     * @description Returns all fiat accounts.
     */
    get: {
      responses: {
        /** @description A fiat account object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["FiatAccount"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/fiat_accounts/{accountId}": {
    /**
     * Find a specific fiat account
     * @description Returns a fiat account by ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the fiat account to return */
          accountId: string;
        };
      };
      responses: {
        /** @description A fiat account object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["FiatAccount"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/fiat_accounts/{accountId}/redeem_to_linked_dda": {
    /**
     * Redeem funds to DDA
     * @description Redeems funds to the linked DDA.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the fiat account to use */
          accountId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            amount?: number;
          };
        };
      };
      responses: {
        /** @description Transfer succeeded */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/fiat_accounts/{accountId}/deposit_from_linked_dda": {
    /**
     * Deposit funds from DDA
     * @description Deposits funds from the linked DDA.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the fiat account to use */
          accountId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            amount?: number;
          };
        };
      };
      responses: {
        /** @description Transfer succeeded */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_connections": {
    /**
     * List network connections
     * @description Returns all network connections.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    get: {
      responses: {
        /** @description A list of network connections */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["NetworkConnectionResponse"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Creates a new network connection
     * @description Initiates a new network connection.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["NetworkConnection"];
        };
      };
      responses: {
        /** @description A Network Connection object */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["NetworkConnectionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_connections/{connectionId}/set_routing_policy": {
    /**
     * Update network connection routing policy.
     * @description Updates an existing network connection's routing policy.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    patch: {
      parameters: {
        path: {
          /** @description The ID of the network connection */
          connectionId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            routingPolicy: components["schemas"]["NetworkConnectionRoutingPolicy"];
          };
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": {
              success: boolean;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_connections/{connectionId}/is_third_party_routing/{assetType}": {
    /**
     * Retrieve third-party network routing validation by asset type.
     * @description The Fireblocks Network allows for flexibility around incoming deposits. A receiver can receive network deposits to locations other than Fireblocks. This endpoint validates whether future transactions are routed to the displayed recipient or to a 3rd party.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the network connection */
          connectionId: string;
          /** @description The destination asset type */
          assetType: "CRYPTO" | "SIGNET" | "SEN" | "SIGNET_TEST" | "SEN_TEST";
        };
      };
      responses: {
        /** @description result for the validation */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": {
              isThirdPartyRouting?: boolean;
              description?: string;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_connections/{connectionId}": {
    /**
     * Get a network connection
     * @description Gets a network connection by ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the connection */
          connectionId: string;
        };
      };
      responses: {
        /** @description A network connection */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["NetworkConnectionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Deletes a network connection by ID
     * @description Deletes an existing network connection specified by its connection ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the network connection to delete */
          connectionId: string;
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": {
              success: boolean;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_ids": {
    /**
     * Returns all network IDs, both local IDs and discoverable remote IDs
     * @description Retrieves a list of all local and discoverable remote network IDs.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    get: {
      responses: {
        /** @description A list of network IDs */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["NetworkIdResponse"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Creates a new Network ID
     * @description Creates a new Network ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    post: {
      requestBody?: {
        content: {
          "application/json": {
            name: string;
            routingPolicy?: components["schemas"]["NetworkIdRoutingPolicy"];
          };
        };
      };
      responses: {
        /** @description Returns the new network ID in your workspace */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["NetworkIdResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_ids/{networkId}": {
    /**
     * Returns specific network ID.
     * @description Retrieves a network by its ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the network */
          networkId: string;
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["NetworkIdResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Deletes specific network ID.
     * @description Deletes a network by its ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the network */
          networkId: string;
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          content: {
            "*/*": {
              success: boolean;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_ids/{networkId}/set_routing_policy": {
    /**
     * Update network id routing policy.
     * @description Updates the routing policy of a specified network ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    patch: {
      parameters: {
        path: {
          /** @description The ID of the network */
          networkId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            routingPolicy: components["schemas"]["NetworkIdRoutingPolicy"];
          };
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": {
              success: boolean;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_ids/{networkId}/set_discoverability": {
    /**
     * Update network ID's discoverability.
     * @description Update whether or not the network ID is discoverable by others.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    patch: {
      parameters: {
        path: {
          /** @description The ID of the network */
          networkId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            isDiscoverable: boolean;
          };
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": {
              success: boolean;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/network_ids/{networkId}/set_name": {
    /**
     * Update network ID's name.
     * @description Updates name of a specified network ID.
     *
     * **Note:** This API call is subject to Flexible Routing Schemes.
     *
     * Your routing policy defines how your transactions are routed.
     * You can choose 1 of the 3 different schemes mentioned below for each asset type:
     *   - **None**; Defines the profile routing to no destination for that asset type. Incoming transactions to asset types routed to `None` will fail.
     *   - **Custom**; Route to an account that you choose. If you remove the account, incoming transactions will fail until you choose another one.
     *   - **Default**; Use the routing specified by the network profile the connection is connected to. This scheme is also referred to as "Profile Routing"
     *
     * Default Workspace Presets:
     *   - Network Profile Crypto → **Custom**
     *   - Network Profile FIAT → **None**
     *   - Network Connection Crypto → **Default**
     *   - Network Connection FIAT → **Default**
     *
     *     - **Note**: By default, Custom routing scheme uses (`dstId` = `0`, `dstType` = `VAULT`).
     */
    patch: {
      parameters: {
        path: {
          /** @description The ID of the network */
          networkId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            name: string;
          };
        };
      };
      responses: {
        /** @description Network ID */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": {
              success: boolean;
            };
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/internal_wallets": {
    /**
     * List internal wallets
     * @description Gets a list of internal wallets.
     *
     * **Note**: BTC-based assets belonging to whitelisted addresses cannot be retrieved between 00:00 UTC and 00:01 UTC daily due to third-party provider, Blockchair, being unavailable for this 60 second period. Please wait until the next minute to retrieve BTC-based assets.
     */
    get: {
      responses: {
        /** @description A list of internal wallets */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create an internal wallet
     * @description Creates a new internal wallet with the requested name.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": {
            /** @description the wallet's display name */
            name?: string;
            /** @description Optional - Sets a customer reference ID */
            customerRefId?: string;
          };
        };
      };
      responses: {
        /** @description A new wallet object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/internal_wallets/{walletId}": {
    /**
     * Get assets for internal wallet
     * @description Returns all assets in an internal wallet by ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the wallet to return */
          walletId: string;
        };
      };
      responses: {
        /** @description A Wallet object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Delete an internal wallet
     * @description Deletes an internal wallet by ID.
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the wallet to delete */
          walletId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/internal_wallets/{walletId}/set_customer_ref_id": {
    /**
     * Set an AML/KYT customer reference ID for an internal wallet
     * @description Sets an AML/KYT customer reference ID for the specific internal wallet.
     */
    post: {
      parameters: {
        path: {
          /** @description The wallet ID */
          walletId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Customer reference ID */
            customerRefId?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/internal_wallets/{walletId}/{assetId}": {
    /**
     * Get an asset from an internal wallet
     * @description Returns information for an asset in an internal wallet.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the wallet */
          walletId: string;
          /** @description The ID of the asset to return */
          assetId: string;
        };
      };
      responses: {
        /** @description A Wallet Asset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["WalletAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Add an asset to an internal wallet
     * @description Adds an asset to an existing internal wallet.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the wallet */
          walletId: string;
          /** @description The ID of the asset to add */
          assetId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            /** @description The wallet's address or, for EOS wallets, the account name */
            address: string;
            /** @description for XRP wallets, the destination tag; for EOS, the memo; for the fiat providers (BLINC by BCB Group), the Bank Transfer Description */
            tag?: string;
          };
        };
      };
      responses: {
        /** @description A Wallet Asset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["WalletAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Delete a whitelisted address from an internal wallet
     * @description Deletes a whitelisted address (for an asset) from an internal wallet.
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the wallet */
          walletId: string;
          /** @description The ID of the asset to delete */
          assetId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/external_wallets": {
    /**
     * List external wallets
     * @description Gets a list of external wallets under the workspace.
     */
    get: {
      responses: {
        /** @description A list of external wallets */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create an external wallet
     * @description Creates a new external wallet with the requested name.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": {
            /** @description the wallet's display name */
            name?: string;
            /** @description Optional - Sets a customer reference ID */
            customerRefId?: string;
          };
        };
      };
      responses: {
        /** @description A Wallet object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/external_wallets/{walletId}": {
    /**
     * Find an external wallet
     * @description Returns an external wallet by ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the wallet to return */
          walletId: string;
        };
      };
      responses: {
        /** @description A Wallet object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Delete an external wallet
     * @description Deletes an external wallet by ID.
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the wallet to delete */
          walletId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/external_wallets/{walletId}/set_customer_ref_id": {
    /**
     * Set an AML customer reference ID for an external wallet
     * @description Sets an AML/KYT customer reference ID for the specific external wallet.
     */
    post: {
      parameters: {
        path: {
          /** @description The wallet ID */
          walletId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** @description Customer reference ID */
            customerRefId?: string;
          };
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/external_wallets/{walletId}/{assetId}": {
    /**
     * Get an asset from an external wallet
     * @description Returns an external wallet by wallet ID and asset ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the wallet */
          walletId: string;
          /** @description The ID of the asset to return */
          assetId: string;
        };
      };
      responses: {
        /** @description A Wallet Asset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExternalWalletAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Add an asset to an external wallet.
     * @description Adds an asset to an existing external wallet.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the wallet */
          walletId: string;
          /** @description The ID of the asset to add */
          assetId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": OneOf<[{
            /** @description The wallet's address (or xpub) of the wallet */
            address: string;
            /** @description For XRP wallets, the destination tag; for EOS/XLM, the memo; for the fiat providers (BLINC by BCB Group), the Bank Transfer Description */
            tag?: string;
          }, {
            additionalInfo: OneOf<[{
              accountHolderGivenName: string;
              accountHolderSurname?: string;
              accountHolderCity: string;
              accountHolderCountry: string;
              accountHolderAddress1: string;
              accountHolderAddress2?: string;
              accountHolderDistrict?: string;
              accountHolderPostalCode: string;
              iban: string;
              ibanCity: string;
              ibanCountry: string;
            }, {
              accountHolderGivenName: string;
              accountHolderSurname?: string;
              accountHolderCity: string;
              accountHolderCountry: string;
              accountHolderAddress1: string;
              accountHolderAddress2?: string;
              accountHolderDistrict?: string;
              accountHolderPostalCode: string;
              abaRoutingNumber: string;
              abaAccountNumber: string;
              abaCountry: string;
            }, {
              speiClabe: string;
              speiName?: string;
            }]>;
          }]>;
        };
      };
      responses: {
        /** @description A Wallet Asset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExternalWalletAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Delete an asset from an external wallet
     * @description Deletes an external wallet asset by ID.
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the wallet */
          walletId: string;
          /** @description The ID of the asset to delete */
          assetId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/contracts": {
    /**
     * List contracts
     * @description Gets a list of contracts.
     */
    get: {
      responses: {
        /** @description A list of contracts */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create a contract
     * @description Creates a new contract.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": {
            /** @description the contract's display name */
            name?: string;
          };
        };
      };
      responses: {
        /** @description A Wallet object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/contracts/{contractId}": {
    /**
     * Find a specific contract
     * @description Returns a contract by ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the contract to return */
          contractId: string;
        };
      };
      responses: {
        /** @description A Wallet object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnmanagedWallet"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Delete a contract
     * @description Deletes a contract by ID.
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the contract to delete */
          contractId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/contracts/{contractId}/{assetId}": {
    /**
     * Find a contract asset
     * @description Returns a contract asset by ID.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the contract */
          contractId: string;
          /** @description The ID of the asset to return */
          assetId: string;
        };
      };
      responses: {
        /** @description A Wallet Asset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExternalWalletAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Add an asset to a contract
     * @description Adds an asset to an existing contract.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the contract */
          contractId: string;
          /** @description The ID of the asset to add */
          assetId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            /** @description The contract's address (or xpub) of the wallet */
            address: string;
            /** @description The destination tag, for XRP wallets */
            tag?: string;
          };
        };
      };
      responses: {
        /** @description A Wallet Asset object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExternalWalletAsset"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Delete a contract asset
     * @description Deletes a contract asset by ID.
     */
    delete: {
      parameters: {
        path: {
          /** @description The ID of the contract */
          contractId: string;
          /** @description The ID of the asset to delete */
          assetId: string;
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/supported_assets": {
    /**
     * List all asset types supported by Fireblocks
     * @description Returns all asset types supported by Fireblocks.
     */
    get: {
      responses: {
        /** @description A Transaction object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["AssetTypeResponse"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/estimate_network_fee": {
    /**
     * Estimate the required fee for an asset
     * @description Gets the estimated required fee for an asset. For UTXO based assets, the response will contain the suggested fee per byte, for ETH/ETC based assets, the suggested gas price, and for XRP/XLM, the transaction fee.
     */
    get: {
      parameters: {
        query: {
          /** @description The asset for which to estimate the fee */
          assetId: string;
        };
      };
      responses: {
        /** @description Estimated fees response */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["EstimatedNetworkFeeResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/validate_address/{assetId}/{address}": {
    /**
     * Validate destination address
     * @description Checks if an address is valid (for XRP, DOT, XLM, and EOS).
     */
    get: {
      parameters: {
        path: {
          /** @description The asset of the address */
          assetId: string;
          /** @description The address to validate */
          address: string;
        };
      };
      responses: {
        /** @description An Transaction object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ValidateAddressResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions": {
    /**
     * List transaction history
     * @description Lists the transaction history for your workspace.
     */
    get: {
      parameters: {
        query?: {
          /** @description Unix timestamp in milliseconds. Returns only transactions created before the specified date */
          before?: string;
          /** @description Unix timestamp in milliseconds. Returns only transactions created after the specified date */
          after?: string;
          /** @description You can filter by one of the statuses. */
          status?: string;
          /**
           * @description The field to order the results by
           *
           * **Note**: Ordering by a field that is not createdAt may result with transactions that receive updates as you request the next or previous pages of results, resulting with missing those transactions.
           */
          orderBy?: "createdAt" | "lastUpdated";
          /** @description The direction to order the results by */
          sort?: "ASC" | "DESC";
          /** @description Limits the number of results. If not provided, a limit of 200 will be used. The maximum allowed limit is 500 */
          limit?: number;
          /** @description The source type of the transaction */
          sourceType?: "VAULT_ACCOUNT" | "EXCHANGE_ACCOUNT" | "INTERNAL_WALLET" | "EXTERNAL_WALLET" | "FIAT_ACCOUNT" | "NETWORK_CONNECTION" | "COMPOUND" | "UNKNOWN" | "GAS_STATION" | "END_USER_WALLET";
          /** @description The source ID of the transaction */
          sourceId?: string;
          /** @description The destination type of the transaction */
          destType?: "VAULT_ACCOUNT" | "EXCHANGE_ACCOUNT" | "INTERNAL_WALLET" | "EXTERNAL_WALLET" | "FIAT_ACCOUNT" | "NETWORK_CONNECTION" | "COMPOUND" | "ONE_TIME_ADDRESS" | "END_USER_WALLET";
          /** @description The destination ID of the transaction */
          destId?: string;
          /** @description A list of assets to filter by, seperated by commas */
          assets?: string;
          /** @description Returns only results with a specified txHash */
          txHash?: string;
          /** @description Returns only results where the source is a specific end user wallet */
          sourceWalletId?: string;
          /** @description Returns only results where the destination is a specific end user wallet */
          destWalletId?: string;
        };
      };
      responses: {
        /** @description A list of transactions */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
            "next-page": components["headers"]["next-page"];
            "prev-page": components["headers"]["prev-page"];
          };
          content: {
            "*/*": components["schemas"]["TransactionResponse"][];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create a new transaction
     * @description Creates a new transaction.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["TransactionRequest"];
        };
      };
      responses: {
        /** @description A transaction object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["CreateTransactionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/estimate_fee": {
    /**
     * Estimate transaction fee
     * @description Estimates the transaction fee for a transaction request.
     *
     * ***Note:***
     *
     * -Supports all Fireblocks assets except ZCash (ZEC).
     *
     * -For XEM and Chiliz assets, 0 will be returned for all three fee levels, as there is no gas or tip price on these blockchains. You can use the POST /v1/transactions/estimate_fee to see what the exact fee will be for a transaction on this network.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["EstimatedFeeRequest"];
        };
      };
      responses: {
        /** @description Estimated fees response */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["EstimatedTransactionFeeResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/{txId}": {
    /**
     * Find a specific transaction by Fireblocks transaction ID
     * @description Returns a transaction by ID.
     */
    get: {
      parameters: {
        path: {
          /**
           * @description The ID of the transaction to return
           * @example 00000000-0000-0000-0000-000000000000
           */
          txId: string;
        };
      };
      responses: {
        /** @description An Transaction object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["TransactionResponse"];
          };
        };
        400: components["responses"]["Error"];
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/external_tx_id/{externalTxId}/": {
    /**
     * Find a specific transaction by external transaction ID
     * @description Returns transaction by external transaction ID.
     */
    get: {
      parameters: {
        path: {
          /**
           * @description The external ID of the transaction to return
           * @example 00000000-0000-0000-0000-000000000000
           */
          externalTxId: string;
        };
      };
      responses: {
        /** @description An Transaction object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["TransactionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/{txId}/set_confirmation_threshold": {
    /**
     * Set confirmation threshold by transaction ID
     * @description Overrides the required number of confirmations for transaction completion by transaction ID.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the transaction */
          txId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["SetConfirmationsThresholdRequest"];
        };
      };
      responses: {
        /** @description Set successfully */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["SetConfirmationsThresholdResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/{txId}/drop": {
    /**
     * Drop ETH transaction by ID
     * @description Drops a stuck ETH transaction and creates a replacement transaction.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the transaction */
          txId: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["DropTransactionRequest"];
        };
      };
      responses: {
        /** @description Created successfully */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["DropTransactionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/{txId}/cancel": {
    /**
     * Cancel a transaction
     * @description Cancels a transaction by ID.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the transaction to cancel */
          txId: string;
        };
      };
      responses: {
        /** @description An Transaction object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["CancelTransactionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/transactions/{txId}/freeze": {
    /**
     * Freeze a transaction
     * @description Freezes a transaction by ID.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the transaction to freeze */
          txId: string;
        };
      };
      responses: {
        /** @description freeze response */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["FreezeTransactionResponse"];
          };
        };
      };
    };
  };
  "/transactions/{txId}/unfreeze": {
    /**
     * Unfreeze a transaction
     * @description Unfreezes a transaction by ID and makes the transaction available again.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the transaction to unfreeze */
          txId: string;
        };
      };
      responses: {
        /** @description Unfreeze response */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["UnfreezeTransactionResponse"];
          };
        };
      };
    };
  };
  "/txHash/{txHash}/set_confirmation_threshold": {
    /**
     * Set confirmation threshold by transaction hash
     * @description Overrides the required number of confirmations for transaction completion by transaction hash.
     */
    post: {
      parameters: {
        path: {
          /** @description The TxHash */
          txHash: string;
        };
      };
      requestBody?: {
        content: {
          "application/json": components["schemas"]["SetConfirmationsThresholdRequest"];
        };
      };
      responses: {
        /** @description A list of transactions affected by the change */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["SetConfirmationsThresholdResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/payments/xb-settlements/configs": {
    /**
     * Get all the cross-border settlement configurations
     * @description Get all the cross-border settlement configurations. </br>
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    get: {
      responses: {
        /** @description Returns all the cross-border settlement configurations */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementGetAllConfigsResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    /**
     * Create a new cross-border settlement configuration
     * @description <u><b>Create a new cross-border settlement configuration. </u></b></br>Configurations define the default assets, on-ramps, and off-ramps to use for the cross-border settlement. </br>
     * A configuration must contain at least two steps - `ON_RAMP` and `VAULT_ACCOUNT`. </br>
     * All other steps (e.g., `OFF_RAMP`, `FIAT_DESTINATION`, etc.) are optional. </br>
     * Every step must include the `accountId` to be used, while `inputAssetId` and `outputAssetId` are optional.
     * If those are not provided, a default value will be used from the Corridor Settings.</br>
     * If the inputAssetId or the outputAssetId is provided for one of the objects, all assets in the objects must be consistent. For example, if the output asset of ON_RAMP is XLM_USDC_5F3T, then the input asset of the VAULT_ACCOUNT must also be XLM_USDC_5F3T..</br>
     * You can set a slippage amount for your configuration. Slippage is defined by basis points (bps). This value can be overloaded on execution. If you do not configure a slippage amount, the default slippage of 10000 bps (10%) is used. </br>
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    post: {
      requestBody?: {
        content: {
          /**
           * @example {
           *   "name": "Flow Config Example",
           *   "corridorId": "CO_US",
           *   "steps": {
           *     "ON_RAMP": {
           *       "accountId": "3b7a1451-3453-4c96-a6a5-683cc8971d04"
           *     },
           *     "VAULT_ACCOUNT": {
           *       "accountId": "2"
           *     },
           *     "OFF_RAMP": {
           *       "accountId": "f2f74204-93ec-4614-870a-4ea2ad13aa0b"
           *     }
           *   },
           *   "conversionSlippageBasisPoints": 75
           * }
           */
          "application/json": components["schemas"]["XBSettlementConfigCreationRequestBody"];
        };
      };
      responses: {
        /** @description Cross-border settlement configuration created successfully */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementConfigCreationResponse"];
          };
        };
        /** @description Error creating cross-border request */
        400: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/xb-settlements/configs/{configId}": {
    /**
     * Get a specific cross-border settlement configuration
     * @description Get a specific cross-border settlement configuration.</br>
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    get: {
      parameters: {
        path: {
          /**
           * @description The cross-border settlement configuration ID.
           * @example 074791cc-ef32-4920-8373-95efbeea66c5
           */
          configId: string;
        };
      };
      responses: {
        /** @description Returns the requested cross-border settlement configuration */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementGetConfigResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description No cross-border settlement configuration exists with the provided ID. */
        404: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    /**
     * Edit a cross-border settlement configuration
     * @description Edit a cross-border settlement configuration.
     * Editing a configuration does not affect previously executed flows that used the configuration.
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    put: {
      parameters: {
        path: {
          /**
           * @description The cross-border settlement configuration ID.
           * @example 074791cc-ef32-4920-8373-95efbeea66c5
           */
          configId: string;
        };
      };
      requestBody?: {
        content: {
          /**
           * @example {
           *   "name": "Flow Config Example - Edited",
           *   "steps": {
           *     "ON_RAMP": {
           *       "accountId": "e9dec04a-3c57-4052-a89a-288c545f6430"
           *     },
           *     "VAULT_ACCOUNT": {
           *       "accountId": "2"
           *     },
           *     "OFF_RAMP": {
           *       "accountId": "f2f74204-93ec-4614-870a-4ea2ad13aa0b"
           *     }
           *   },
           *   "corridorId": "CO_US",
           *   "conversionSlippageBasisPoints": 30
           * }
           */
          "application/json": components["schemas"]["XBSettlementConfigEditRequestBody"];
        };
      };
      responses: {
        /** @description Cross-border settlement configuration edited successfully */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementConfigEditResponse"];
          };
        };
        /** @description Error creating the cross-border request. Configuration not modified. */
        400: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description No cross-border settlement configuration exists with the provided ID. */
        404: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
    /**
     * Delete a cross-border settlement configuration
     * @description Delete a cross-border settlement configuration.
     * This does not delete or remove previously executed flows that used this configuration.
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    delete: {
      parameters: {
        path: {
          /**
           * @description The cross-border settlement configuration ID.
           * @example 074791cc-ef32-4920-8373-95efbeea66c5
           */
          configId: string;
        };
      };
      responses: {
        /** @description Cross-border settlement configuration deleted successfully. Returns the deleted configuration. */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementConfigDeletionResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description No cross-border settlement configuration exists with the provided ID. */
        404: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/xb-settlements/flows": {
    /**
     * Create a new cross-border settlement flow
     * @description Create a cross-border flow (based on a cross-border configuration) with an amount to transfer.
     * The assetId is defined by the cross-border configuration.
     * Creating a flow triggers a calculation of the flow estimations, including FX rates, times, and fees based on the amount provided.
     * Creating a cross-border flow will not execute the flow.
     *
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    post: {
      requestBody?: {
        content: {
          /**
           * @example {
           *   "configId": "a4b0a706-4578-4467-bd5b-a852761dd2aa",
           *   "amount": "100"
           * }
           */
          "application/json": components["schemas"]["XBSettlementCreateFlowRequestBody"];
        };
      };
      responses: {
        /** @description Cross-border settlement flow created successfully */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementCreateFlowResponse"];
          };
        };
        /** @description Unable to create cross-border flow, invalid configuration ID. */
        400: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/xb-settlements/flows/{flowId}": {
    /**
     * Get specific cross-border settlement flow details
     * @description Gets details for a specific cross-border settlement flow
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    get: {
      parameters: {
        path: {
          /**
           * @description The cross-border settlement flow ID.
           * @example 98fb5a8b-65ff-4f15-b89c-80910aedbfb3
           */
          flowId: string;
        };
      };
      responses: {
        /**
         * @description Returns cross-border settlement flow details.
         * For unexecuted flows, a preview object will return, showing the estimated time, amounts, and fees.
         * Note that this data structure updates as the flow progresses, including the total fees (accumulated), state, and steps.
         */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementGetFlowResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Invalid flowId. */
        404: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/xb-settlements/flows/{flowId}/actions/execute": {
    /**
     * Execute cross-border settlement flow
     * @description Send a payment flow with 'flowId' for execution.
     * If a differet slippage configuraion is needed for this execution than configured in the flow configuration, the request body must define the desired slippage configuration for this execution.
     *
     * **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoint includes APIs available only for customers with the Payments Engine enabled on their accounts.
     * These endpoints are currently in beta and might be subject to changes.
     * If you want to learn more about the Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    post: {
      parameters: {
        path: {
          /**
           * @description The cross-border settlement flow ID.
           * @example 98fb5a8b-65ff-4f15-b89c-80910aedbfb3
           */
          flowId: string;
        };
      };
      requestBody?: {
        content: {
          /**
           * @example {
           *   "conversionSlippageBasisPoints": 10
           * }
           */
          "application/json": components["schemas"]["XBSettlementFlowExecutionRequestBody"];
        };
      };
      responses: {
        /** @description Cross-border settlement flow started to execute successfully */
        200: {
          content: {
            "application/json": components["schemas"]["XBSettlementFlowExecutionResponse"];
          };
        };
        /** @description Error while trying to execute the cross-border flow */
        400: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Invalid flowId. */
        404: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/payout": {
    /**
     * Create a payout instruction set
     * @description **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br>
     * </br>These endpoints are currently in beta and might be subject to changes.</br>
     * </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br>
     * </br> <b u>Create a payout instruction set.</b> </u></br>
     * A payout instruction set is a set of instructions for distributing payments from a single payment account to a list of payee accounts. </br>
     * The instruction set defines: </br>
     * <ul>
     * <li>the payment account and its account type (vault, exchange, or fiat). </li>
     * <li>the account type (vault account, exchange account, whitelisted address, network connection, fiat account, or merchant account), the amount, and the asset of payment for each payee account.</li>
     * </ul>
     */
    post: {
      requestBody?: {
        content: {
          /**
           * @example {
           *   "paymentAccount": {
           *     "id": "EX_SUB3",
           *     "type": "EXCHANGE_ACCOUNT"
           *   },
           *   "instructionSet": [
           *     {
           *       "payeeAccount": {
           *         "id": "bef85a1c-b605-4b2e-bdb5-2d400f4d0bf3",
           *         "type": "EXTERNAL_WALLET"
           *       },
           *       "amount": {
           *         "amount": "43",
           *         "assetId": "USDC"
           *       }
           *     },
           *     {
           *       "payeeAccount": {
           *         "id": "3adc1f92-e791-44a8-9aee-7f31c2108b78",
           *         "type": "NETWORK_CONNECTION"
           *       },
           *       "amount": {
           *         "amount": "4423",
           *         "assetId": "USDC"
           *       }
           *     }
           *   ]
           * }
           */
          "application/json": components["schemas"]["CreatePayoutRequest"];
        };
      };
      responses: {
        /** @description The payout instruction set creation succeeded and returns the generated instruction set with a unique payout IDThe payout ID will be used for executing the payout and checking the payout status. */
        200: {
          content: {
            "application/json": components["schemas"]["PayoutResponse"];
          };
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/payout/{payoutId}/actions/execute": {
    /**
     * Execute a payout instruction set
     * @description **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br>
     * </br>These endpoints are currently in beta and might be subject to changes.</br>
     * </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br>
     * </br><b u>Execute a payout instruction set.</b> </u> </br>
     * </br>The instruction set will be verified and executed.</br>
     * <b><u>Source locking</br></b> </u>
     * If you are executing a payout instruction set from a payment account with an already active payout the active payout will complete before the new payout instruction set can be executed. </br>
     * You cannot execute the same payout instruction set more than once.
     */
    post: {
      parameters: {
        path: {
          /**
           * @description the payout id received from the creation of the payout instruction set
           * @example 1fe3b61f-7e1f-4a19-aff0-4f0a524d44d7
           */
          payoutId: string;
        };
      };
      responses: {
        /** @description Executed the payout instruction set */
        200: {
          content: {
            "application/json": components["schemas"]["DispatchPayoutResponse"];
          };
        };
        /** @description Bad request */
        400: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/payments/payout/{payoutId}": {
    /**
     * Get the status of a payout instruction set
     * @description **Note:** The reference content in this section documents the Payments Engine endpoint. The Payments Engine endpoints include APIs available only for customers with Payments Engine enabled on their accounts. </br>
     * </br>These endpoints are currently in beta and might be subject to changes.</br>
     * </br>If you want to learn more about Fireblocks Payments Engine, please contact your Fireblocks Customer Success Manager or email CSM@fireblocks.com. </br>
     */
    get: {
      parameters: {
        path: {
          /**
           * @description the payout id received from the creation of the payout instruction set
           * @example 1fe3b61f-7e1f-4a19-aff0-4f0a524d44d7
           */
          payoutId: string;
        };
      };
      responses: {
        /** @description Returns the current status of the payout instruction set, including the status of each payout instruction and the transactions created in the process. */
        200: {
          content: {
            "application/json": components["schemas"]["PayoutResponse"];
          };
        };
        /** @description Unauthorized. Missing / invalid JWT token in Authorization header. */
        401: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description No payout with the given payout ID exists. */
        404: {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error. */
        "5XX": {
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
      };
    };
  };
  "/gas_station": {
    /**
     * Get gas station settings
     * @description Returns gas station settings and ETH balance.
     */
    get: {
      responses: {
        /** @description Gas Station properties */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["GasStationPropertiesResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/gas_station/{assetId}": {
    /**
     * Get gas station settings by asset
     * @description Returns gas station settings and balances for a requested asset.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      responses: {
        /** @description Gas Station properties */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["GasStationPropertiesResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/gas_station/configuration": {
    /**
     * Edit gas station settings
     * @description Configures gas station settings for ETH.
     */
    put: {
      requestBody: {
        content: {
          "application/json": components["schemas"]["GasStationConfiguration"];
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/gas_station/configuration/{assetId}": {
    /**
     * Edit gas station settings for an asset
     * @description Configures gas station settings for a requested asset.
     */
    put: {
      parameters: {
        path: {
          /** @description The ID of the asset */
          assetId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["GasStationConfiguration"];
        };
      };
      responses: {
        /** @description OK */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/management/user_groups": {
    /**
     * List user groups
     * @description Get all user groups in the current workspace.
     */
    get: operations["getUserGroups"];
    /**
     * Create a user group
     * @description Create a new user group.</br>
     */
    post: operations["createUserGroup"];
  };
  "/management/user_groups/{groupId}": {
    /**
     * Get a user group by ID
     * @description Get a user group by ID.</br>
     */
    get: operations["getUserGroup"];
    /**
     * Update user group
     * @description Update a users group by ID.</br>
     *
     * **Note**:
     * - Please note that this endpoint is available only for API keys with Admin permissions.
     */
    put: operations["updateUserGroup"];
    /**
     * Delete user group
     * @description Delete a user group by ID.</br>
     *
     * **Note**:
     * - Please note that this endpoint is available only for API keys with Admin permissions.
     */
    delete: operations["deleteUserGroup"];
  };
  "/users": {
    /**
     * List users
     * @description List all users for the workspace.
     *
     * Please note that this endpoint is available only for API keys with Admin permissions.
     */
    get: {
      responses: {
        /** @description List of users */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["GetUsersResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/audits": {
    /** Get audit logs */
    get: {
      parameters: {
        query: {
          /** @description The last time period to fetch audit logs */
          timePeriod: "DAY" | "WEEK";
        };
      };
      responses: {
        /** @description Audit logs from requested time period */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/management/audit_logs": {
    /**
     * Get audit logs
     * @description Get audit logs
     */
    get: operations["getAudits"];
  };
  "/off_exchange/add": {
    /**
     * add collateral
     * @description add collateral, create deposit request
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["AddCollateralRequestBody"];
        };
      };
      responses: {
        /** @description A transaction object */
        200: {
          content: {
            "*/*": components["schemas"]["CreateTransactionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/off_exchange/remove": {
    /**
     * remove collateral
     * @description remove collateral, create withdraw request
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["RemoveCollateralRequestBody"];
        };
      };
      responses: {
        /** @description A transaction object */
        200: {
          content: {
            "*/*": components["schemas"]["CreateTransactionResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/off_exchange/settlements/trader": {
    /**
     * create settlement for a trader
     * @description create settlement for a trader
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["SettlementRequestBody"];
        };
      };
      responses: {
        /** @description A settlement object */
        201: {
          content: {
            "*/*": components["schemas"]["SettlementResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/off_exchange/settlements/transactions": {
    /**
     * get settlements transactions from exchange
     * @description get settlements transactions from exchange
     */
    get: {
      parameters: {
        query: {
          mainExchangeAccountId: string;
        };
      };
      responses: {
        /** @description A settlement transactions */
        200: {
          content: {
            "*/*": components["schemas"]["GetSettlementResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/off_exchange/collateral_accounts/{mainExchangeAccountId}": {
    /**
     * Find a specific collateral exchange account
     * @description Returns a collateral account by mainExchangeAccountId.
     */
    get: {
      parameters: {
        path: {
          /** @description The id of the main exchange account for which the requested collateral account is associated with */
          mainExchangeAccountId: string;
        };
      };
      responses: {
        /** @description An ExchangeAccount object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ExchangeAccount"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/webhooks/resend": {
    /**
     * Resend failed webhooks
     * @description Resends all failed webhook notifications.
     */
    post: {
      responses: {
        /** @description OK */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["ResendWebhooksResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/webhooks/resend/{txId}": {
    /**
     * Resend failed webhooks for a transaction by ID
     * @description Resends failed webhook notifications for a transaction by ID.
     */
    post: {
      parameters: {
        path: {
          /** @description The ID of the transaction for webhooks */
          txId: string;
        };
      };
      requestBody: {
        content: {
          "application/json": {
            resendCreated?: boolean;
            resendStatusUpdated?: boolean;
          };
        };
      };
      responses: {
        /** @description OK */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/nfts/ownership/tokens": {
    /**
     * List all owned tokens (paginated)
     * @description Returns all tokens and their data in your workspace.
     */
    get: operations["getOwnedNFTs"];
    /**
     * Refresh vault account tokens
     * @description Updates all tokens and balances per blockchain and vault account.
     */
    put: operations["refreshNFTOwnershipByVault"];
  };
  "/nfts/ownership/assets": {
    /**
     * List all distinct owned tokens (paginated)
     * @description Returns all owned distinct tokens (for your tenant) and their data in your workspace.
     */
    get: operations["listOwnedTokens"];
  };
  "/nfts/ownership/collections": {
    /**
     * List owned collections (paginated)
     * @description Returns all collections in your workspace
     */
    get: operations["listOwnedCollections"];
  };
  "/nfts/tokens/{id}": {
    /**
     * List token data by ID
     * @description Returns the requested token data.
     */
    get: operations["getNFT"];
    /**
     * Refresh token metadata
     * @description Updates the latest token metadata.
     */
    put: operations["refreshNFTMetadata"];
  };
  "/nfts/tokens": {
    /**
     * List tokens by IDs
     * @description Returns the requested tokens data.
     */
    get: operations["getNFTs"];
  };
  "/nfts/ownership/tokens/{id}/status": {
    /**
     * Update token ownership status
     * @description Updates token status for a tenant, in all tenant vaults.
     */
    put: operations["updateTokenOwnershipStatus"];
  };
  "/nfts/ownership/tokens/status": {
    /**
     * Update tokens ownership status
     * @description Updates tokens status for a tenant, in all tenant vaults.
     */
    put: operations["updateTokensOwnershipStatus"];
  };
  "/api/v1/nfts/ownership/tokens/spam": {
    /**
     * Update tokens ownership spam statuses
     * @description Updates tokens spam value for a tenant, in all tenant vaults.
     */
    put: operations["updateTokensOwnershipSpam"];
  };
  "/connections": {
    /**
     * List all open dApp connections
     * @description List all open dApp connections.
     */
    get: operations["get"];
  };
  "/connections/wc": {
    /**
     * Create a new dApp connection
     * @description Create a new dApp connection.
     *
     * * Note: After this succeeds, make a request to `PUT /v1/connections/wc/{id}` (below) to approve or reject the new dApp connection.
     */
    post: operations["create"];
  };
  "/connections/wc/{id}": {
    /**
     * Respond to a pending dApp connection request
     * @description Submit a response to *approve* or *reject* an initiated dApp connection.
     * * Note: This call is used to complete your `POST /v1/connections/wc/` request.
     *
     * After this succeeds, your new dApp connection is created and functioning.
     */
    put: operations["submit"];
    /**
     * Remove an existing dApp connection
     * @description Remove an existing dApp connection
     */
    delete: operations["remove"];
  };
  "/screening/travel_rule/transaction/validate": {
    /**
     * Validate Travel Rule Transaction
     * @description Validate Travel Rule transactions.
     *
     * Checks what beneficiary VASP details are required by your jurisdiction and the beneficiary's jurisdiction.
     *
     * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    post: operations["TravelRuleApiController_validate"];
  };
  "/screening/travel_rule/transaction/validate/full": {
    /**
     * Validate Full Travel Rule Transaction
     * @description Validate Full Travel Rule transactions.
     *
     * Checks for all required information on the originator and beneficiary VASPs.
     *
     * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    post: operations["TravelRuleApiController_validateFull"];
  };
  "/screening/travel_rule/vasp/{did}": {
    /**
     * Get VASP details
     * @description Get VASP Details.
     *
     * Returns information about a VASP that has the specified DID.
     *
     * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    get: operations["TravelRuleApiController_findVasp"];
  };
  "/screening/travel_rule/vasp": {
    /**
     * Get All VASPs
     * @description Get All VASPs.
     *
     * Returns a list of VASPs. VASPs can be searched and sorted and results are paginated.
     *
     * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    get: operations["TravelRuleApiController_findAllVasp"];
  };
  "/screeening/travel_rule/vasp/update": {
    /**
     * Add jsonDidKey to VASP details
     * @description Update VASP Details.
     *
     * Updates a VASP with the provided parameters. Use this endpoint to add your public jsonDIDkey generated by Notabene.
     *
     * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    put: operations["TravelRuleApiController_updateVasp"];
  };
  "/management/ota": {
    /**
     * Return status of One Time Address (OTA) enabled
     * @description Returns current One Time Address (OTA) status
     */
    get: operations["getOtaStatus"];
    /**
     * Enable or disable transactions to One Time Address (OTA)
     * @description Enable or disable transactions to One Time Address (OTA)
     */
    post: operations["setOtaStatus"];
  };
  "/management/workspace_status": {
    /**
     * Return current workspace status
     * @description Returns the status of the current workspace.
     */
    get: operations["getWorkspaceStatus"];
  };
  "/tap/active_policy": {
    /**
     * Get the active policy and its validation
     * @description Returns the active policy and its validation. </br>
     * **Note:** These endpoints are currently in beta and might be subject to changes.
     * If you want to participate and learn more about the Fireblocks TAP, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    get: {
      responses: {
        /** @description A policy object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["PolicyAndValidationResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/tap/draft": {
    /**
     * Get the active draft
     * @description Returns the active draft and its validation. </br>
     * **Note:** These endpoints are currently in beta and might be subject to changes.
     * If you want to participate and learn more about the Fireblocks TAP, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    get: {
      responses: {
        /** @description A draft validation response object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["DraftReviewAndValidationResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Update the draft with a new set of rules
     * @description Update the draft and return its validation. </br>
     * **Note:** These endpoints are currently in beta and might be subject to changes.
     * If you want to participate and learn more about the Fireblocks TAP, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    put: {
      requestBody: {
        content: {
          "application/json": {
            /** @description rules to update the draft with */
            rules?: components["schemas"]["PolicyRule"][];
          };
        };
      };
      responses: {
        /** @description A draft validation response object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["DraftReviewAndValidationResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Send publish request for a certain draft id
     * @description Send publish request of certain draft id and returns the response. </br>
     * **Note:** These endpoints are currently in beta and might be subject to changes.
     * If you want to participate and learn more about the Fireblocks TAP, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    post: {
      requestBody: {
        content: {
          "application/json": {
            /** @description draft unique identifier */
            draftId?: string;
          };
        };
      };
      responses: {
        /** @description A policy publish result object */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["PublishResult"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/tap/publish": {
    /**
     * Send publish request for a set of policy rules
     * @description Send publish request of set of policy rules and returns the response. </br>
     * **Note:** These endpoints are currently in beta and might be subject to changes.
     * If you want to participate and learn more about the Fireblocks TAP, please contact your Fireblocks Customer Success Manager or send an email to CSM@fireblocks.com.
     */
    post: {
      requestBody: {
        content: {
          "application/json": {
            /** @description Policy rules to publish */
            rules?: components["schemas"]["PolicyRule"][];
          };
        };
      };
      responses: {
        /** @description A policy publish result object */
        201: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["PublishResult"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/batch/jobs": {
    /**
     * Return a list of jobs belonging to a workspace.
     * @description Get an array of objects including all active, paused, canceled, and complete jobs in a workspace.</br>
     * **Note:** The reference content in this section documents the Batch Control beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    get: {
      parameters: {
        query?: {
          fromTime?: number;
          toTime?: number;
        };
      };
      responses: {
        /** @description An array of jobs */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["Jobs"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/batch/{jobId}": {
    /**
     * Get job details
     * @description Get an object describing the given job.</br>
     * **Note:** The reference content in this section documents the Batch Control beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    get: {
      parameters: {
        path: {
          jobId: string;
        };
      };
      responses: {
        /** @description A Job object */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["Job"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/batch/{jobId}/pause": {
    /**
     * Pause a job
     * @description Pause the given job, after the current task is done. A paused job can later be resumed by calling ‘continue’, or canceled.</br>
     * **Note:** The reference content in this section documents the Batch Control beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    post: {
      parameters: {
        path: {
          jobId: string;
        };
      };
      responses: {
        /** @description paused successfully */
        200: {
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/batch/{jobId}/continue": {
    /**
     * Continue a paused job
     * @description Continue the given paused job.</br>
     * **Note:** The reference content in this section documents the Batch Control beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    post: {
      parameters: {
        path: {
          jobId: string;
        };
      };
      responses: {
        /** @description continued successfully */
        200: {
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/batch/{jobId}/cancel": {
    /**
     * Cancel a running job
     * @description Stop the given job immediately. If the job is in the ‘Active’ state, the job will be canceled after completing the current task. Vault accounts and Wallets that are already created will not be affected.</br>
     * **Note:** The reference content in this section documents the Batch Control beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    post: {
      parameters: {
        path: {
          jobId: string;
        };
      };
      responses: {
        /** @description canceled successfully */
        200: {
          content: never;
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/batch/{jobId}/tasks": {
    /**
     * Return a list of tasks for given job
     * @description Return a list of tasks for a given job.</br>
     * **Note:** The reference content in this section documents the Batch Control beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
     *
     * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
     */
    get: {
      parameters: {
        path: {
          jobId: string;
        };
      };
      responses: {
        /** @description An array of tasks */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "*/*": components["schemas"]["Tasks"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/management/users": {
    /**
     * Get Console users
     * @description Gets a list of Console users from the current tenant.
     */
    get: {
      responses: {
        /** @description Get Console users */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Unauthorized. Missing or invalid JWT token in Authorization header */
        401: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Lacking permissions */
        403: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error */
        "5XX": {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Create Console user
     * @description Creates a Fireblocks Console user
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["CreateConsoleUser"];
        };
      };
      responses: {
        /** @description Users sent for creation */
        204: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Bad request */
        400: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Unauthorized. Missing or invalid JWT token in Authorization header */
        401: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Lacking permissions. */
        403: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error */
        "5XX": {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/management/api_users": {
    /**
     * Get API users (Beta)
     * @description Get API users from the current tenant. </br>
     * - **Note: This endpoint is in beta and subject to change**
     */
    get: {
      responses: {
        /** @description Get API users */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Unauthorized. Missing or invalid JWT token in Authorization header. */
        401: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Lacking permissions */
        403: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error */
        "5XX": {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
    /**
     * Creates an API user (Beta)
     * @description Creates an API user.
     * - **Note: This endpoint is in beta and subject to change**
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["CreateAPIUser"];
        };
      };
      responses: {
        /** @description User sent for creation */
        204: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Unauthorized. Missing or invalid JWT token in Authorization header. */
        401: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Lacking permissions */
        403: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error */
        "5XX": {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/management/users/{id}/reset_device": {
    /**
     * Reset device
     * @description Re-links a mobile device to the workspace
     */
    post: {
      parameters: {
        path: {
          /** @description The user’s ID */
          id: string;
        };
      };
      responses: {
        /** @description User sent for creation */
        204: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Unauthorized. Missing or invalid JWT token in Authorization header. */
        401: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Lacking permissions */
        403: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error */
        "5XX": {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/management/api_users/{userId}/whitelist_ip_addresses": {
    /**
     * Get list of whitelisted IP addresses
     * @description Gets a list of whitelisted IP addresses, which make it possible to get API calls only from these IP addresses.
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the user */
          userId: string;
        };
      };
      responses: {
        /** @description successfully whitelisted */
        200: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: never;
        };
        /** @description Unauthorized. Missing or invalid JWT token in Authorization header. */
        401: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Lacking permissions */
        403: {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        /** @description Internal error */
        "5XX": {
          headers: {
            "X-Request-ID": components["headers"]["X-Request-ID"];
          };
          content: {
            "application/json": components["schemas"]["ErrorResponse"];
          };
        };
        default: components["responses"]["Error"];
      };
    };
  };
  "/smart-transfers": {
    /**
     * Find Ticket
     * @description Finds Smart Transfer tickets that match the submitted criteria
     */
    get: operations["searchTickets"];
    /**
     * Create Ticket
     * @description Creates new Smart Transfer ticket
     */
    post: operations["createTicket"];
  };
  "/smart-transfers/{ticketId}": {
    /**
     * Search Tickets by ID
     * @description Find Smart Transfer ticket by id
     */
    get: operations["findTicketById"];
  };
  "/smart-transfers/{ticketId}/expires-in": {
    /**
     * Set expiration
     * @description Set expiration date on Smart Transfer ticket
     */
    put: operations["setTicketExpiration"];
  };
  "/smart-transfers/{ticketId}/external-id": {
    /**
     * Add external ref. ID
     * @description Set external id Smart Transfer ticket
     */
    put: operations["setExternalRefId"];
  };
  "/smart-transfers/{ticketId}/submit": {
    /**
     * Submit ticket
     * @description Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
     */
    put: operations["submitTicket"];
  };
  "/smart-transfers/{ticketId}/fulfill": {
    /**
     * Fund ticket manually
     * @description Manually fulfill ticket, in case when all terms (legs) are funded manually
     */
    put: operations["fulfillTicket"];
  };
  "/smart-transfers/{ticketId}/cancel": {
    /**
     * Cancel Ticket
     * @description Cancel Smart Transfer ticket
     */
    put: operations["cancelTicket"];
  };
  "/smart-transfers/{ticketId}/terms": {
    /**
     * Search ticket by leg (term) ID
     * @description Creates new smart transfer ticket term (when the ticket status is DRAFT)
     */
    post: operations["createTicketTerm"];
  };
  "/smart-transfers/{ticketId}/terms/{termId}": {
    /** @description Find Smart Transfer ticket term by id */
    get: operations["findTicketTermById"];
    /**
     * Update ticket leg (term)
     * @description Update ticket term (when ticket status is DRAFT)
     */
    put: operations["updateTicketTerm"];
    /**
     * Delete ticket leg (term)
     * @description Delete ticket term when ticket is in DRAFT status
     */
    delete: operations["removeTicketTerm"];
  };
  "/smart-transfers/{ticketId}/terms/{termId}/fund": {
    /**
     * Define funding source
     * @description Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
     */
    put: operations["fundTicketTerm"];
  };
  "/smart-transfers/{ticketId}/terms/{termId}/manually-fund": {
    /**
     * Manually add term transaction
     * @description Manually set ticket term transaction
     */
    put: operations["manuallyFundTicketTerm"];
  };
  "/smart-transfers/settings/user-groups": {
    /**
     * Get user group
     * @description Get Smart Transfer user groups
     */
    get: operations["getSmartTransferUserGroups"];
    /**
     * Set user group
     * @description Set Smart Transfer user group
     */
    post: operations["setUserGroups"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    MediaEntityResponse: {
      /** @description Cached accessible URL */
      url: string;
      /**
       * @description Media type
       * @enum {string}
       */
      contentType: "IMAGE" | "VIDEO" | "ANIMATION" | "THREE_D" | "TEXT" | "GIF" | "UNKNOWN_TYPE" | "SVG" | "AUDIO";
    };
    SpamOwnershipResponse: {
      /** @description Token spam result */
      result: boolean;
      /**
       * @description Source of Token's Spam status value
       * @enum {string}
       */
      source: "OWNER" | "SYSTEM";
    };
    TokenCollectionResponse: {
      id: string;
      name?: string;
      symbol?: string;
    };
    SpamTokenResponse: {
      /** @description Token spam result */
      result: boolean;
    };
    TokenResponse: {
      /** @description The Fireblocks NFT asset id */
      id: string;
      /** @description Token id within the contract/collection */
      tokenId: string;
      /** @description ERC721 / ERC1155 */
      standard: string;
      /** @description URL of the original token JSON metadata */
      metadataURI?: string;
      /** @description URL of the cached token JSON metadata */
      cachedMetadataURI?: string;
      /** @description Media items extracted from metadata JSON */
      media?: components["schemas"]["MediaEntityResponse"][];
      /** @description Token spam status */
      spam?: components["schemas"]["SpamTokenResponse"];
      /** @description Parent collection information */
      collection?: components["schemas"]["TokenCollectionResponse"];
      /** @enum {string} */
      blockchainDescriptor: "ETH" | "ETH_TEST3" | "ETH_TEST5" | "POLYGON" | "POLYGON_TEST_MUMBAI" | "XTZ" | "XTZ_TEST" | "BASECHAIN_ETH";
      description?: string;
      name?: string;
    };
    UpdateTokenOwnershipStatusDto: {
      /** @enum {string} */
      status: "LISTED" | "ARCHIVED";
    };
    TokenOwnershipStatusUpdatePayload: {
      /**
       * @description Token's asset id
       * @example NFT-abcdefabcdefabcdefabcdefabcdefabcdefabcd
       */
      assetId: string;
      /**
       * @description Token's ownership new status
       * @example ARCHIVED
       * @enum {string}
       */
      status: "LISTED" | "ARCHIVED";
    };
    TokenOwnershipSpamUpdatePayload: {
      /**
       * @description Token's asset id
       * @example NFT-abcdefabcdefabcdefabcdefabcdefabcdefabcd
       */
      assetId: string;
      /** @description Token's ownership new spam value */
      spam: boolean;
    };
    Paging: {
      /** @description Cursor to the next page */
      next: string;
    };
    TokenOwnershipResponse: {
      /** @description The Fireblocks NFT asset id */
      id: string;
      /** @description Token id within the contract/collection */
      tokenId: string;
      /** @description ERC721 / ERC1155 */
      standard: string;
      /** @description URL of the original token JSON metadata */
      metadataURI?: string;
      /** @description URL of the cached token JSON metadata */
      cachedMetadataURI?: string;
      /** @description Media items extracted from metadata JSON */
      media: components["schemas"]["MediaEntityResponse"][];
      /** @description Owned Token's Spam status */
      spam?: components["schemas"]["SpamOwnershipResponse"];
      /** @description Parent collection information */
      collection?: components["schemas"]["TokenCollectionResponse"];
      balance: string;
      vaultAccountId: string;
      ownershipStartTime: number;
      ownershipLastUpdateTime: number;
      /** @enum {string} */
      blockchainDescriptor: "ETH" | "ETH_TEST3" | "ETH_TEST5" | "POLYGON" | "POLYGON_TEST_MUMBAI" | "XTZ" | "XTZ_TEST" | "BASECHAIN_ETH";
      description: string;
      name: string;
      ncwId?: string;
      ncwAccountId?: string;
      /**
       * @description Owned Token's status
       * @enum {string}
       */
      status: "LISTED" | "ARCHIVED";
    };
    CollectionOwnershipResponse: {
      /** @description Fireblocks collection id */
      id: string;
      /** @description Collection name */
      name?: string;
      /** @description Collection symbol */
      symbol?: string;
      /** @description Collection contract standard */
      standard?: string;
      /**
       * @description Collection's blockchain
       * @enum {string}
       */
      blockchainDescriptor: "ETH" | "ETH_TEST3" | "ETH_TEST5" | "POLYGON" | "POLYGON_TEST_MUMBAI" | "XTZ" | "XTZ_TEST" | "BASECHAIN_ETH";
      /** @description Collection contract standard */
      contractAddress?: string;
    };
    WalletAsset: {
      id?: string;
      balance?: string;
      lockedAmount?: string;
      status?: components["schemas"]["ConfigChangeRequestStatus"];
      address?: string;
      tag?: string;
      activationTime?: string;
    };
    ExternalWalletAsset: {
      id?: string;
      status?: components["schemas"]["ConfigChangeRequestStatus"];
      address?: string;
      tag?: string;
      activationTime?: string;
      additionalInfo?: components["schemas"]["WalletAssetAdditionalInfo"][];
    };
    WalletAssetAdditionalInfo: {
      accountHolderGivenName?: string;
      accountHolderSurname?: string;
      accountHolderCity?: string;
      accountHolderCountry?: string;
      accountHolderAddress1?: string;
      accountHolderAddress2?: string;
      accountHolderDistrict?: string;
      accountHolderPostalCode?: string;
      abaRoutingNumber?: string;
      abaAccountNumber?: string;
      abaCountry?: string;
      iban?: string;
      ibanCity?: string;
      ibanCountry?: string;
      speiClabe?: string;
      speiName?: string;
    };
    ExchangeAsset: {
      id?: string;
      balance?: string;
      lockedAmount?: string;
      total?: string;
      available?: string;
    };
    ExchangeTradingAccount: {
      type?: string;
      name?: string;
      assets?: components["schemas"]["ExchangeAsset"][];
    };
    FiatAsset: {
      id?: string;
      balance?: string;
    };
    CreateVaultAssetResponse: {
      id?: string;
      address?: string;
      legacyAddress?: string;
      enterpriseAddress?: string;
      tag?: string;
      eosAccountName?: string;
      status?: string;
      activationTxId?: string;
    };
    RewardsInfo: {
      /** @description Amount that is pending for rewards */
      pendingRewards?: string;
    };
    VaultAsset: {
      id?: string;
      /** @description The total wallet balance. In EOS this value includes the network balance, self staking and pending refund. For all other coins it is the balance as it appears on the blockchain. */
      total?: string;
      /**
       * @deprecated
       * @description Deprecated - replaced by "total"
       */
      balance?: string;
      /** @description Funds available for transfer. Equals the blockchain balance minus any locked amounts */
      available?: string;
      /** @description The cumulative balance of all transactions pending to be cleared */
      pending?: string;
      /** @description The cumulative frozen balance */
      frozen?: string;
      /** @description Funds in outgoing transactions that are not yet published to the network */
      lockedAmount?: string;
      /** @description Staked balance */
      staked?: string;
      /** @description Deprecated */
      totalStakedCPU?: number;
      /** @description Deprecated */
      totalStakedNetwork?: string;
      /** @description Deprecated */
      selfStakedCPU?: string;
      /** @description Deprecated */
      selfStakedNetwork?: string;
      /** @description Deprecated */
      pendingRefundCPU?: string;
      /** @description Deprecated */
      pendingRefundNetwork?: string;
      blockHeight?: string;
      blockHash?: string;
      rewardsInfo?: components["schemas"]["RewardsInfo"];
    };
    VaultWalletAddress: {
      assetId?: string;
      address?: string;
      description?: string;
      tag?: string;
      type?: string;
      customerRefId?: string;
      /** @enum {string} */
      addressFormat?: "SEGWIT" | "LEGACY";
      legacyAddress?: string;
      enterpriseAddress?: string;
      bip44AddressIndex?: number;
      userDefined?: boolean;
    };
    CreateAddressResponse: {
      address?: string;
      legacyAddress?: string;
      enterpriseAddress?: string;
      tag?: string;
      bip44AddressIndex?: number;
    };
    VaultAccountsPagedResponse: {
      accounts?: components["schemas"]["VaultAccount"][];
      paging?: {
        before?: string;
        after?: string;
      };
      previousUrl?: string;
      nextUrl?: string;
    };
    PaginatedAssetWalletResponse: {
      assetWallets?: components["schemas"]["AssetWallet"][];
      paging?: {
        /** @description A string representing a cursor. Users can use this with a new request to this API endpoint as the “before” request parameter to fetch the previous page of results. */
        before?: string;
        /** @description A string representing a cursor. Users can use this with a new request to this API endpoint as the “before” request parameter to fetch the next page of results. */
        after?: string;
      };
    };
    AssetWallet: {
      /** @description ID of the vault account. You can [get the vault account by this ID](https://developers.fireblocks.com/reference/get_vault-accounts-vaultaccountid) to retrieve vault properties such as its name, auto fueling, hidden on UI or customer reference ID. */
      vaultId?: string;
      /** @description ID of the asset. You can get more information about this asset by using the [supported assets API](https://developers.fireblocks.com/reference/get_supported-assets) */
      assetId?: string;
      /** @description Available balance, available to use in a transaction. */
      available?: string;
      /** @description Total balance at the asset wallet, as seen at the blockchain explorers. This includes balance available, and any kind of unavailable balance such as locked, frozen, or others. */
      total?: string;
      /** @description Pending balance. */
      pending?: string;
      /** @description Staked balance. */
      staked?: string;
      /** @description Funds frozen due to the anti-money laundering policy at this workspace. */
      frozen?: string;
      /** @description Locked balance. */
      lockedAmount?: string;
      /** @description The height (number) of the block of the balance. Can by empty. */
      blockHeight?: string;
      /** @description The hash of the block of the balance. Can by empty. */
      blockHash?: string;
      /** @description Unix timestamp of the time the asset wallet was created. */
      creationTimestamp?: string;
    };
    VaultAccount: {
      id?: string;
      name?: string;
      assets?: components["schemas"]["VaultAsset"][];
      hiddenOnUI?: boolean;
      customerRefId?: string;
      autoFuel?: boolean;
    };
    UnmanagedWallet: {
      id: string;
      name: string;
      customerRefId?: string;
      assets?: components["schemas"]["WalletAsset"][];
    };
    ExchangeAccount: {
      id?: string;
      type?: components["schemas"]["ExchangeType"];
      /** @description Display name of the exchange account */
      name?: string;
      status?: string;
      assets?: components["schemas"]["ExchangeAsset"][];
      tradingAccounts?: components["schemas"]["ExchangeTradingAccount"][];
      /** @description True if the account is a subaccount in an exchange */
      isSubaccount?: boolean;
      /** @description if the account is a sub-account, the ID of the main account */
      mainAccountId?: string;
    };
    ExchangeAccountsPaged: {
      ExchangeAccount?: components["schemas"]["ExchangeAccount"][];
      paging?: {
        /** @description Query value to the after page */
        after?: string;
        /** @description Query value to the before page */
        before?: string;
      };
      prevUrl?: string;
      nextUrl?: string;
    };
    FiatAccount: {
      id?: string;
      type?: components["schemas"]["FiatAccountType"];
      /** @description Display name of the fiat account */
      name?: string;
      address?: string;
      assets?: components["schemas"]["FiatAsset"][];
    };
    OneTimeAddress: {
      address: string;
      tag?: string;
    };
    TransferPeerPath: {
      /** @enum {string} */
      type: "VAULT_ACCOUNT" | "EXCHANGE_ACCOUNT" | "INTERNAL_WALLET" | "EXTERNAL_WALLET" | "NETWORK_CONNECTION" | "FIAT_ACCOUNT" | "COMPOUND" | "GAS_STATION" | "ONE_TIME_ADDRESS" | "UNKNOWN" | "END_USER_WALLET";
      /** @enum {string} */
      subType?: "BINANCE" | "BINANCEUS" | "BITFINEX" | "BITHUMB" | "BITMEX" | "BITSO" | "BITSTAMP" | "BITTREX" | "BLINC" | "BYBIT" | "CIRCLE" | "COINBASEEXCHANGE" | "COINBASEPRO" | "COINMETRO" | "COINSPRO" | "CRYPTOCOM" | "DERIBIT" | "GEMINI" | "HITBTC" | "HUOBI" | "INDEPENDENTRESERVE" | "KORBIT" | "KRAKEN" | "KRAKENINTL" | "KUCOIN" | "LIQUID" | "OKCOIN" | "OKEX" | "PAXOS" | "POLONIEX" | "External" | "Internal";
      id?: string;
      name?: string;
      /** Format: uuid */
      walletId?: string;
    };
    DestinationTransferPeerPath: components["schemas"]["TransferPeerPath"] & Record<string, never> & {
      oneTimeAddress?: components["schemas"]["OneTimeAddress"];
    };
    CreateTransactionResponse: {
      /** @description The ID of the transaction. */
      id?: string;
      /** @description The primary status of the transaction. For details, see [Primary transaction statuses.] (https://developers.fireblocks.com/reference/primary-transaction-statuses) */
      status?: string;
      systemMessages?: components["schemas"]["SystemMessageInfo"];
    };
    SystemMessageInfo: {
      /** @enum {string} */
      type?: "WARN" | "BLOCK";
      /**
       * @description A response from Fireblocks that communicates a message about the health of the process being performed. If this object is returned with data, you should expect potential delays or incomplete transaction statuses.
       * @example Slow transaction processing. Outgoing transactions might be stuck.
       */
      message?: string;
    };
    CancelTransactionResponse: {
      success?: boolean;
    };
    UnfreezeTransactionResponse: {
      success?: boolean;
    };
    FreezeTransactionResponse: {
      success?: boolean;
    };
    /** @description The result of the AML screening. */
    AmlScreeningResult: {
      provider?: string;
      payload?: Record<string, never>;
    };
    /** @description Details of the transaction's fee. */
    FeeInfo: {
      /** @description The fee paid to the network */
      networkFee?: string;
      /** @description The total fee deducted by the exchange from the actual requested amount (serviceFee = amount - netAmount) */
      serviceFee?: string;
      gasPrice?: string;
    };
    /**
     * @description The block hash and height of the block that this transaction was mined in.
     *      **Note**: If an outgoing transaction uses the destinations object with more than one value in the array, blockHash is set to null.
     */
    BlockInfo: {
      blockHeight?: string;
      blockHash?: string;
    };
    /** @description The information about your [Transaction Authorization Policy (TAP).](https://developers.fireblocks.com/docs/capabilities#transaction-authorization-policy-tap) */
    AuthorizationInfo: {
      allowOperatorAsAuthorizer?: boolean;
      /** @enum {string} */
      logic?: "AND" | "OR";
      groups?: components["schemas"]["AuthorizationGroups"][];
    };
    AuthorizationGroups: {
      th?: number;
      users?: {
        [key: string]: "PENDING_AUTHORIZATION" | "APPROVED" | "REJECTED" | "NA";
      };
    };
    /** @description The details of the requested amount to transfer. */
    AmountInfo: {
      /** @description If the transfer is a withdrawal from an exchange, the actual amount that was requested to be transferred. Otherwise, the requested amount. */
      amount?: string;
      /** @description The amount requested by the user. */
      requestedAmount?: string;
      /** @description The net amount of the transaction, after fee deduction. */
      netAmount?: string;
      /** @description The USD value of the requested amount. */
      amountUSD?: string;
    };
    /** @description This field is relevant only for Algorand transactions. Both `srcRewards` and `destRewards` will appear only for Vault to Vault transactions, otherwise you will receive only the Fireblocks’ side of the transaction. */
    RewardInfo: {
      srcRewards?: string;
      destRewards?: string;
    };
    SourceTransferPeerPathResponse: components["schemas"]["TransferPeerPath"] & {
      type?: string;
      /** @description In case the type is set to `EXCHANGE_ACCOUNT` or `FIAT_ACCOUNT`, the specific exchange vendor name or fiat vendor name. In case the type is set to `INTERNAL_WALLET` or `EXTERNAL_WALLET`, the subType is set to `Internal` or `External`. */
      subType?: string;
      /** @description The ID of the peer. You can retrieve the ID of each venue object using the endpoints for [listing vault accounts](https://developers.fireblocks.com/reference/get_vault-accounts-paged), [listing exchange account](https://developers.fireblocks.com/reference/get_exchange-accounts), [listing fiat accounts](https://developers.fireblocks.com/reference/get_fiat-accounts), [listing internal wallets](https://developers.fireblocks.com/reference/get_internal-wallets), [listing external wallets](https://developers.fireblocks.com/reference/get_external-wallets), [listing network connections](https://developers.fireblocks.com/reference/get_network-connections). For the other types, this parameter is not needed. */
      id?: string;
      /** @description The name of the peer. */
      name?: string;
    };
    DestinationTransferPeerPathResponse: components["schemas"]["TransferPeerPath"] & {
      type?: string;
      /** @description In case the type is set to `EXCHANGE_ACCOUNT` or `FIAT_ACCOUNT`, the specific exchange vendor name or fiat vendor name.In case the type is set to `INTERNAL_WALLET` or `EXTERNAL_WALLET`, the subType is set to `Internal` or `External`. */
      subType?: string;
      /** @description The ID of the peer. You can retrieve the ID of each venue object using the endpoints for [listing vault accounts](https://developers.fireblocks.com/reference/get_vault-accounts-paged), [listing exchange account](https://developers.fireblocks.com/reference/get_exchange-accounts), [listing fiat accounts](https://developers.fireblocks.com/reference/get_fiat-accounts), [listing internal wallets](https://developers.fireblocks.com/reference/get_internal-wallets), [listing external wallets](https://developers.fireblocks.com/reference/get_external-wallets), [listing network connections](https://developers.fireblocks.com/reference/get_network-connections). For the other types, this parameter is not needed. */
      id?: string;
      /** @description The name of the peer. */
      name?: string;
    };
    TransactionResponse: {
      /** @description ID of the transaction. */
      id?: string;
      /** @description Unique transaction ID provided by the user. Fireblocks highly recommends setting an `externalTxId` for every transaction created, to avoid submitting the same transaction twice. */
      externalTxId?: string;
      /** @description The primary status of the transaction. For details, see [Primary transaction statuses](https://developers.fireblocks.com/reference/primary-transaction-statuses). */
      status?: string;
      /** @description See [Transaction substatuses](https://developers.fireblocks.com/reference/transaction-substatuses) for the list of transaction sub statuses. */
      subStatus?: string;
      /**
       * @description The hash of the transaction on the blockchain.
       *  * This parameter exists if at least one of the following conditions is met:
       *
       *      1. The transaction’s source type is `UNKNOWN`, `WHITELISTED_ADDRESS`, `NETWORK_CONNECTION`, `ONE_TIME_ADDRESS`, `FIAT_ACCOUNT` or `GAS_STATION`.
       *
       *      2. The transaction’s source type is `VAULT` and the status is either: `CONFIRMING`, `COMPLETED`, or was in any of these statuses prior to changing to `FAILED` or `REJECTED`. In some instances, transactions in status `BROADCASTING` will include the txHash as well.
       *
       *      3. The transaction’s source type is `EXCHANGE_ACCOUNT` and the transaction’s destination type is `VAULT`, and the status is either: `CONFIRMING`, `COMPLETED`, or was in any of these status prior to changing to `FAILED`.
       *
       *
       * * In addition, the following conditions must be met:
       *
       *     1. The asset is a crypto asset (not fiat).
       *
       *     2. The transaction operation is not RAW or `TYPED_MESSAGE`.
       */
      txHash?: string;
      operation?: components["schemas"]["GetTransactionOperation"];
      /** @description Custom note, not sent to the blockchain, that describes the transaction at your Fireblocks workspace. */
      note?: string;
      /** @description The ID of the asset to transfer, for `TRANSFER`, `MINT`, `BURN`, `ENABLE_ASSET`,`STAKE` ,`UNSTAKE` or `WITHDRAW` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets) */
      assetId?: string;
      source?: components["schemas"]["SourceTransferPeerPathResponse"];
      /**
       * @description For account based assets only, the source address of the transaction.
       * **Note:** If the status is `CONFIRMING`, `COMPLETED`, or has been `CONFIRMING`; then moved forward to `FAILED` or `REJECTED`, then this parameter will contain the source address. In any other case, this parameter will be empty.
       */
      sourceAddress?: string;
      /** @description Source address tag for XRP, used as memo for EOS/XLM, or Bank Transfer Description for the fiat provider BLINC (by BCB Group). */
      tag?: string;
      destination?: components["schemas"]["DestinationTransferPeerPathResponse"];
      /**
       * @description The transaction’s destinations.
       * **Note:** In case the transaction is sent to a single destination, the `destination` parameter is used instead of this.
       */
      destinations?: components["schemas"]["TransactionResponseDestination"][];
      /**
       * @description Address where the asset were transferred.
       * Notes:
       *   - For [Multi destination transactions](https://support.fireblocks.io/hc/en-us/articles/360018447980-Multi-destination-transactions), this parameter will be empty. In this case, you should refer to the destinations field.
       *   - If the status is `CONFIRMING`, `COMPLETED`, or has been `CONFIRMING`; then moved forward to `FAILED` or `REJECTED`, then this parameter will contain the destination address. In any other case, this parameter will be empty.
       */
      destinationAddress?: string;
      /** @description Description of the address. */
      destinationAddressDescription?: string;
      /** @description Destination address tag for XRP, used as memo for EOS/XLM, or Bank Transfer Description for the fiat provider BLINC (by BCB Group). */
      destinationTag?: string;
      /** @description Decoded data for `CONTRACT_CALL` operations. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for setting this parameter's value. */
      contractCallDecodedData?: {
        contractName?: string;
        functionCalls?: Record<string, never>[];
      };
      amountInfo?: components["schemas"]["AmountInfo"];
      /**
       * @description For transactions initiated via this Fireblocks workspace, when set to `true`, the fee is deducted from the requested amount.
       *
       * **Note**: This parameter can only be considered if a transaction's asset is a base asset, such as ETH or MATIC. If the asset can't be used for transaction fees, like USDC, this parameter is ignored and the fee is deducted from the relevant base asset wallet in the source account.
       */
      treatAsGrossAmount?: boolean;
      feeInfo?: components["schemas"]["FeeInfo"];
      /** @description The asset which was withdrawn to pay the transaction fee, for example ETH for EVM-based blockchains, BTC for Tether Omni. */
      feeCurrency?: string;
      /** @description In case a single transaction resulted with multiple transfers, for example a result of a contract call, then this parameter specifies each transfer that took place on the blockchain. In case of a single transfer transaction, this parameter is empty. */
      networkRecords?: components["schemas"]["NetworkRecord"][];
      /** @description The transaction’s creation date and time, in unix timestamp. */
      createdAt?: number;
      /** @description The transaction’s last update date and time, in unix timestamp. */
      lastUpdated?: number;
      /** @description User ID of the initiator of the transaction. */
      createdBy?: string;
      /** @description User ID’s of the signers of the transaction. */
      signedBy?: string[];
      /** @description User ID of the user that rejected the transaction (in case it was rejected). */
      rejectedBy?: string;
      authorizationInfo?: components["schemas"]["AuthorizationInfo"];
      /** @description If the transaction originated from an exchange, this is the ID of this transaction at the exchange. */
      exchangeTxId?: string;
      /** @description The ID for AML providers to associate the owner of funds with transactions. */
      customerRefId?: string;
      amlScreeningResult?: components["schemas"]["AmlScreeningResult"];
      extraParameters?: components["schemas"]["ExtraParameters"];
      signedMessages?: components["schemas"]["SignedMessage"];
      /** @description The number of confirmations of the transaction. The number will increase until the transaction will be considered completed according to the confirmation policy. */
      numOfConfirmations?: number;
      blockInfo?: components["schemas"]["BlockInfo"];
      /**
       * @description For UTXO based assets this is the vOut, for Ethereum based, this is the index of the event of the contract call.
       *  **Note:** This field is not returned if a transaction uses the `destinations` object with more than one value.
       */
      index?: number;
      rewardInfo?: components["schemas"]["RewardInfo"];
      systemMessages?: components["schemas"]["SystemMessageInfo"];
      /** @enum {string} */
      addressType?: "WHITELISTED" | "ONE_TIME";
      /**
       * @deprecated
       * @description The amount requested by the user. Deprecated - please use the `amountInfo` field for accuracy.
       */
      requestedAmount?: number;
      /**
       * @deprecated
       * @description If the transfer is a withdrawal from an exchange, the actual amount that was requested to be transferred. Otherwise, the requested amount. Deprecated - please use the `amountInfo` field for accuracy.
       */
      amount?: number;
      /**
       * @deprecated
       * @description The net amount of the transaction, after fee deduction. Deprecated - please use the `amountInfo` field for accuracy.
       */
      netAmount?: number;
      /**
       * @deprecated
       * @description The USD value of the requested amount. Deprecated - please use the `amountInfo` field for accuracy.
       */
      amountUSD?: number | null;
      /**
       * @deprecated
       * @description The total fee deducted by the exchange from the actual requested amount (`serviceFee` = `amount` - `netAmount`). Deprecated - please use the `feeInfo` field for accuracy.
       */
      serviceFee?: number;
      /**
       * @deprecated
       * @description Deprecated - please use the `feeInfo` field for accuracy.
       */
      fee?: number;
      /**
       * @deprecated
       * @description The fee paid to the network. Deprecated - please use the `feeInfo` field for accuracy.
       */
      networkFee?: number;
    };
    TransactionResponseDestination: {
      destination?: components["schemas"]["DestinationTransferPeerPathResponse"];
      /** @description Address where the asset was transferred. */
      destinationAddress?: unknown;
      /** @description Description of the address. */
      destinationAddressDescription?: unknown;
      /** @description The amount to be sent to this destination. */
      amount?: string;
      /** @description The USD value of the requested amount. */
      amountUSD?: string;
      amlScreeningResult?: components["schemas"]["AmlScreeningResult"];
      /** @description The ID for AML providers to associate the owner of funds with transactions. */
      customerRefId?: unknown;
      authorizationInfo?: components["schemas"]["AuthorizationInfo"];
    };
    NetworkRecord: {
      source?: components["schemas"]["SourceTransferPeerPathResponse"];
      destination?: components["schemas"]["DestinationTransferPeerPathResponse"];
      txHash?: string;
      networkFee?: string;
      assetId?: string;
      /** @description The net amount of the transaction, after fee deduction */
      netAmount?: string;
      isDropped?: boolean;
      type?: string;
      destinationAddress?: string;
      sourceAddress?: string;
      amountUSD?: string;
      index?: number;
      rewardInfo?: components["schemas"]["RewardInfo"];
    };
    AssetTypeResponse: {
      id: string;
      name: string;
      /** @enum {string} */
      type: "ALGO_ASSET" | "BASE_ASSET" | "BEP20" | "COMPOUND" | "ERC20" | "FIAT" | "SOL_ASSET" | "TRON_TRC20" | "XLM_ASSET" | "XDB_ASSET";
      contractAddress?: string;
      nativeAsset?: string;
      decimals?: number;
    };
    NetworkConnection: {
      /** @description The network ID of the profile trying to create the connection. */
      localNetworkId: string;
      /** @description The network ID the profile is attempting to connect to. */
      remoteNetworkId: string;
      routingPolicy?: components["schemas"]["NetworkConnectionRoutingPolicy"];
    };
    NetworkConnectionResponse: {
      id: string;
      /**
       * @deprecated
       * @description Deprecated - Replaced by `localNetworkId`
       */
      localChannel?: components["schemas"]["NetworkChannel"];
      /**
       * @deprecated
       * @description Deprecated - Replaced by `remoteNetworkId`
       */
      remoteChannel?: components["schemas"]["NetworkChannel"];
      status: components["schemas"]["ConfigChangeRequestStatus"];
      localNetworkId: components["schemas"]["NetworkId"];
      remoteNetworkId: components["schemas"]["NetworkId"];
      routingPolicy: components["schemas"]["NetworkConnectionRoutingPolicy"];
    };
    EstimatedTransactionFeeResponse: {
      low: components["schemas"]["TransactionFee"];
      medium: components["schemas"]["TransactionFee"];
      high: components["schemas"]["TransactionFee"];
    };
    EstimatedNetworkFeeResponse: {
      low: components["schemas"]["NetworkFee"];
      medium: components["schemas"]["NetworkFee"];
      high: components["schemas"]["NetworkFee"];
    };
    GasStationPropertiesResponse: {
      balance?: Record<string, never>;
      configuration?: components["schemas"]["GasStationConfiguration"];
    };
    TransactionFee: {
      feePerByte?: string;
      gasPrice?: string;
      gasLimit?: string;
      networkFee?: string;
      /** @description (optional) Base Fee according to EIP-1559 (ETH assets) */
      baseFee?: string;
      /** @description (optional) Priority Fee according to EIP-1559 (ETH assets) */
      priorityFee?: string;
    };
    NetworkFee: {
      feePerByte?: string;
      gasPrice?: string;
      networkFee?: string;
      /** @description (optional) Base Fee according to EIP-1559 (ETH assets) */
      baseFee?: string;
      /** @description (optional) Priority Fee according to EIP-1559 (ETH assets) */
      priorityFee?: string;
    };
    GasStationConfiguration: {
      gasThreshold?: string;
      gasCap?: string;
      maxGasPrice?: string;
    };
    /**
     * @deprecated
     * @description Deprecated in the only used reference - NetworkConnectionResponse
     */
    NetworkChannel: {
      networkId?: string;
      name?: string;
    };
    NetworkId: {
      id: string;
      name: string;
    };
    NetworkIdResponse: components["schemas"]["NetworkId"] & {
      routingPolicy?: components["schemas"]["NetworkIdRoutingPolicy"];
      /** @description The specific network is discoverable. */
      isDiscoverable?: boolean;
    };
    TransactionRequest: {
      operation?: components["schemas"]["TransactionOperation"];
      /**
       * @description Custom note, not sent to the blockchain, to describe the transaction at your Fireblocks workspace.
       * @example Ticket 123
       */
      note?: string;
      /**
       * @description An optional but highly recommended parameter. Fireblocks will reject future transactions with same ID.
       *
       * You should set this to a unique ID representing the transaction, to avoid submitting the same transaction twice. This helps with cases where submitting the transaction responds with an error code due to Internet interruptions, but the transaction was actually sent and processed. To validate whether a transaction has been processed, [Find a specific transaction by external transaction ID](https://developers.fireblocks.com/reference/get_transactions-external-tx-id-externaltxid).
       *
       * There is no specific format required for this parameter.
       * @example 00000000-0000-0000-0000-000000000000
       */
      externalTxId?: string;
      /**
       * @description The ID of the asset to transfer, for `TRANSFER`, `MINT` or `BURN` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets)
       * @example ETH
       */
      assetId?: string;
      source?: components["schemas"]["TransferPeerPath"];
      destination?: components["schemas"]["DestinationTransferPeerPath"];
      /** @description For UTXO based blockchains, you can send a single transaction to multiple destinations. */
      destinations?: components["schemas"]["TransactionRequestDestination"][];
      /** @description For `TRANSFER` operations, the requested amount to transfer, in the asset’s unit. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. */
      amount?: string | number;
      /**
       * @description "When set to `true`, the fee will be deducted from the requested amount."
       *
       * **Note**: This parameter can only be considered if a transaction’s asset is a base asset, such as ETH or MATIC. If the asset can’t be used for transaction fees, like USDC, this parameter is ignored and the fee is deducted from the relevant base asset wallet in the source account.
       * @example false
       */
      treatAsGrossAmount?: boolean;
      /**
       * @description For Polkadot, Kusama and Westend transactions only. When set to true, Fireblocks will empty the asset wallet.
       *
       *    **Note:** If set to true when the source account is exactly 1 DOT, the transaction will fail. Any amount more or less than 1 DOT succeeds. This is a Polkadot blockchain limitation.
       * @example false
       */
      forceSweep?: boolean;
      /**
       * @description For UTXO or EVM-based blockchains only. Defines the blockchain fee level which will be payed for the transaction. Alternatively, specific fee estimation parameters exist below.
       * @example MEDIUM
       * @enum {string}
       */
      feeLevel?: "LOW" | "MEDIUM" | "HIGH";
      /** @description For UTXO-based blockchains, the fee per bytes in the asset’s smallest unit (Satoshi, Latoshi, etc.).  For Ripple, the fee for the transaction. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. */
      fee?: string | number;
      /** @description For Ethereum-based blockchains only, the fee for EIP-1559 transaction pricing mechanism. Value is in Gwei.  Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. */
      priorityFee?: string | number;
      /** @description When set to `true`, in case the current `MEDIUM` fee level is higher than the one specified in the transaction, the transaction will fail to avoid getting stuck with no confirmations. */
      failOnLowFee?: boolean;
      /**
       * @description The maximum fee (gas price or fee per byte) that should be payed for the transaction.  In case the current value of the requested `feeLevel` is higher than this requested maximum fee.  Represented by a numeric string for accurate precision.
       * @example 120
       */
      maxFee?: string;
      /** @description For EVM-based blockchains only. Units of gas required to process the transaction. Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. */
      gasLimit?: string | number;
      /** @description For non-EIP-1559, EVM-based transactions. Price per gas unit (in Ethereum this is specified in Gwei).  Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision.  Although a number input exists, it is deprecated. */
      gasPrice?: string | number;
      /**
       * @description For EVM-based blockchains only. The total transaction fee in the blockchain’s largest unit. Note: Only two of the three arguments can be specified in a single transaction: `gasLimit`, `gasPrice` and `networkFee`. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. - The transaction blockchain fee.
       * - For Ethereum, you can't pass gasPrice, gasLimit and networkFee all together.
       * - A numeric value representation is required.
       */
      networkFee?: string | number;
      /**
       * @description For EVM-based blockchains only. In case a transaction is stuck, specify the hash of the stuck transaction to replace it by this transaction with a higher fee, or to replace it with this transaction with a zero fee and drop it from the blockchain.
       * @example 00000000-0000-0000-0000-000000000000
       */
      replaceTxByHash?: string;
      extraParameters?: components["schemas"]["ExtraParameters"];
      /**
       * @description The ID for AML providers to associate the owner of funds with transactions.
       * @example abcdef
       */
      customerRefId?: string;
      /**
       * @deprecated
       * @description This feature is no longer supported.
       */
      autoStaking?: boolean;
      /**
       * @deprecated
       * @description This feature is no longer supported.
       */
      networkStaking?: string | number;
      /**
       * @deprecated
       * @description This feature is no longer supported.
       */
      cpuStaking?: string | number;
    };
    EstimatedFeeRequest: {
      operation?: components["schemas"]["TransactionOperation"];
      /**
       * @description The ID of the asset to transfer, for `TRANSFER`, `MINT` or `BURN` operations. [See the list of supported assets and their IDs on Fireblocks.](https://developers.fireblocks.com/reference/get_supported-assets)
       * @example ETH
       */
      assetId?: string;
      source?: components["schemas"]["TransferPeerPath"];
      destination?: components["schemas"]["DestinationTransferPeerPath"];
      /** @description For UTXO based blockchains, you can send a single transaction to multiple destinations. */
      destinations?: components["schemas"]["TransactionRequestDestination"][];
      /** @description For `TRANSFER` operations, the requested amount to transfer, in the asset’s unit. Fireblocks recommends using a numeric string for accurate precision. Although a number input exists, it is deprecated. */
      amount?: string | number;
      /**
       * @description "When set to `true`, the fee will be deducted from the requested amount."
       *
       * **Note**: This parameter can only be considered if a transaction’s asset is a base asset, such as ETH or MATIC. If the asset can’t be used for transaction fees, like USDC, this parameter is ignored and the fee is deducted from the relevant base asset wallet in the source account.
       * @example false
       */
      treatAsGrossAmount?: boolean;
      extraParameters?: components["schemas"]["ExtraParameters"];
    };
    TransactionRequestDestination: {
      amount?: string;
      destination?: components["schemas"]["DestinationTransferPeerPath"];
    };
    /** @enum {string} */
    ExchangeType: "BINANCE" | "BINANCEUS" | "BITFINEX" | "BITHUMB" | "BITMEX" | "BITSO" | "BITSTAMP" | "BITTREX" | "CIRCLE" | "COINBASEPRO" | "COINMETRO" | "COINSPRO" | "CRYPTOCOM" | "DERIBIT" | "FTX" | "FIXUS" | "GEMINI" | "HITBTC" | "HUOBI" | "KORBIT" | "KRAKEN" | "LIQUID" | "POLONIEX" | "OKCOIN" | "OKEX" | "SEEDCX";
    /** @enum {string} */
    FiatAccountType: "BLINC";
    /** @enum {string} */
    ConfigChangeRequestStatus: "WAITING_FOR_APPROVAL" | "APPROVED" | "CANCELLED" | "REJECTED" | "FAILED";
    /**
     * @description * `TRANSFER` - The default value for an operation. Transfers funds from one account to another. UTXO blockchains allow multi-input and multi-output transfers. All other blockchains allow transfers with one source address and one destination address.
     * * `MINT` - Mints new tokens. Supported for Stellar, Ripple and EVM-based blockchains.
     * * `BURN` - Burns tokens. Supported for Stellar, Ripple and EVM-based blockchains.
     * * `CONTRACT_CALL` - Calls a smart contract method for web3 operations on any EVM blockchain. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions.
     * * `TYPED_MESSAGE` - An off-chain message in either Ethereum Personal Message or EIP712 format. Use it to sign specific readable messages that are not actual transactions. [Learn more about typed messages](https://developers.fireblocks.com/docs/typed-message-signing).
     * * `RAW` - An off-chain message with no predefined format. Use it to sign any message with your private key, including protocols such as blockchains and custom transaction types that are not natively supported by Fireblocks. [Learn more about raw signing transactions.](https://developers.fireblocks.com/docs/raw-message-signing)
     *
     * @default TRANSFER
     * @enum {string}
     */
    TransactionOperation: "TRANSFER" | "BURN" | "CONTRACT_CALL" | "MINT" | "RAW" | "TYPED_MESSAGE";
    /**
     * @description * `TRANSFER` - Transfers funds from one account to another. UTXO blockchains allow multi-input and multi-output transfers. All other blockchains allow transfers with one source address and one destination address.
     * * `MINT` - Mints new tokens. Supported for Stellar, Ripple and EVM-based blockchains.
     * * `BURN` - Burns tokens. Supported for Stellar, Ripple and EVM-based blockchains.
     * * `CONTRACT_CALL` - Calls a smart contract method for web3 operations on any EVM blockchain. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions.
     * * `TYPED_MESSAGE` - An off-chain message in either Ethereum Personal Message or EIP712 format. Use it to sign specific readable messages that are not actual transactions. [Learn more about typed messages](https://developers.fireblocks.com/docs/typed-message-signing).
     * * `RAW` - An off-chain message with no predefined format. Use it to sign any message with your private key, including protocols such as blockchains and custom transaction types that are not natively supported by Fireblocks. [Learn more about raw signing transactions.](https://developers.fireblocks.com/docs/raw-message-signing)
     * * `ENABLE_ASSET` - Algorand, DigitalBits, Solana, and Stellar require an on-chain transaction to create an asset wallet and enable the deposit address. This transaction is automatically created when adding assets on these blockchains at a vault account.
     * * `STAKE` - Assign assets to a staking pool managed by a staking validator. Supported for Stellar and EVM-based blockchains. This transaction is automatically created when performing staking operations.
     * * `UNSTAKE` - Remove assets from a staking pool managed by a staking validator. Supported for Stellar and EVM-based blockchains. This transaction is automatically created when performing staking operations.
     * * `WITHDRAW` - Transfer assets from a dedicated staking vault account to another address. Supported for Stellar and EVM-based blockchains. This transaction is automatically created when performing staking operations.
     *
     *     **Note:** Fireblocks will rename this type from `WITHDRAW` to a different type name soon. There will be a 7-day notice regarding the new type name.
     *
     * * `SUPPLY_TO_COMPOUND` - Deprecated since April 1st, 2023. Older transactions may have this as their operation, in case users in the workspace have used the direct integration between Fireblocks and the Compound DeFI protocol.
     * * `REDEEM_FROM_COMPOUND` - Deprecated since April 1st, 2023. Older transactions may have this as their operation, in case users in the workspace have used the direct integration between Fireblocks and the Compound DeFI protocol.
     *
     * @enum {string}
     */
    GetTransactionOperation: "TRANSFER" | "BURN" | "CONTRACT_CALL" | "MINT" | "RAW" | "TYPED_MESSAGE" | "ENABLE_ASSET" | "STAKE" | "UNSTAKE" | "WITHDRAW" | "REDEEM_FROM_COMPOUND" | "SUPPLY_TO_COMPOUND";
    Error: {
      message?: string;
      code?: number;
    };
    Term: {
      networkConnectionId?: string;
      outgoing?: boolean;
      asset?: string;
      amount?: string;
      note?: string;
      operation?: string;
    };
    SetConfirmationsThresholdRequest: {
      numOfConfirmations?: number;
    };
    SetConfirmationsThresholdResponse: {
      success?: boolean;
      transactions?: string[];
    };
    DropTransactionRequest: {
      txId?: string;
      feeLevel?: string;
      gasPrice?: string;
    };
    DropTransactionResponse: {
      success?: boolean;
      transactions?: string[];
    };
    UnsignedMessage: {
      content: string;
      bip44addressIndex?: number;
      bip44change?: number;
      derivationPath?: number[];
    };
    /** @description A list of signed messages returned for raw signing. */
    SignedMessage: {
      content?: string;
      /** @enum {string} */
      algorithm?: "MPC_ECDSA_SECP256K1" | "MPC_EDDSA_ED25519";
      derivationPath?: number[];
      signature?: {
        fullSig?: string;
        r?: string;
        s?: string;
        v?: number;
      };
      publicKey?: string;
    };
    PublicKeyInformation: {
      algorithm?: string;
      derivationPath?: number[];
      publicKey?: string;
    };
    /** @enum {string} */
    TradingAccountType: "COIN_FUTURES" | "COIN_MARGINED_SWAP" | "EXCHANGE" | "FUNDING" | "FUNDABLE" | "FUTURES" | "FUTURES_CROSS" | "MARGIN" | "MARGIN_CROSS" | "OPTIONS" | "SPOT" | "USDT_MARGINED_SWAP_CROSS" | "USDT_FUTURES" | "UNIFIED";
    ValidateAddressResponse: {
      isValid?: boolean;
      isActive?: boolean;
      requiresTag?: boolean;
    };
    ResendWebhooksResponse: {
      messagesCount?: number;
    };
    UnspentInputsResponse: {
      input?: components["schemas"]["UnspentInput"];
      address?: string;
      amount?: string;
      confirmations?: number;
      status?: string;
    };
    UnspentInput: {
      txHash?: string;
      index?: number;
    };
    GetUsersResponse: {
      users?: components["schemas"]["UserResponse"][];
    };
    /**
     * @description Additional protocol / operation specific key-value parameters:
     *
     * For UTXO-based blockchain input selection, add the key `inputsSelection` with the value set the [input selection structure.](https://developers.fireblocks.com/reference/transaction-objects#inputsselection) The inputs can be retrieved from the [Retrieve Unspent Inputs endpoint.](https://developers.fireblocks.com/reference/get_vault-accounts-vaultaccountid-assetid-unspent-inputs)
     *
     * For `RAW` operations, add the key `rawMessageData` with the value set to the [raw message data structure.](https://developers.fireblocks.com/reference/raw-signing-objects#rawmessagedata)
     *
     * For `CONTRACT_CALL` operations, add the key `contractCallData` with the value set to the Ethereum smart contract Application Binary Interface (ABI) payload. The Fireblocks [development libraries](https://developers.fireblocks.com/docs/ethereum-development#convenience-libraries) are recommended for building contract call transactions.
     */
    ExtraParameters: Record<string, never>;
    NetworkIdRoutingPolicy: {
      crypto?: components["schemas"]["CustomCryptoRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"];
      sen?: components["schemas"]["CustomFiatRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"];
      signet?: components["schemas"]["CustomFiatRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"];
      sen_test?: components["schemas"]["NoneNetworkRoutingDest"] | components["schemas"]["CustomFiatRoutingDest"];
      signet_test?: components["schemas"]["NoneNetworkRoutingDest"] | components["schemas"]["CustomFiatRoutingDest"];
    };
    NetworkConnectionRoutingPolicy: {
      crypto?: components["schemas"]["CustomCryptoRoutingDest"] | components["schemas"]["DefaultNetworkRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"];
      sen?: components["schemas"]["CustomFiatRoutingDest"] | components["schemas"]["DefaultNetworkRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"];
      signet?: components["schemas"]["DefaultNetworkRoutingDest"] | components["schemas"]["CustomFiatRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"];
      sen_test?: components["schemas"]["DefaultNetworkRoutingDest"] | components["schemas"]["NoneNetworkRoutingDest"] | components["schemas"]["CustomFiatRoutingDest"];
      signet_test?: components["schemas"]["NoneNetworkRoutingDest"] | components["schemas"]["CustomFiatRoutingDest"] | components["schemas"]["DefaultNetworkRoutingDest"];
    };
    CustomFiatRoutingDest: {
      /**
       * @description The network routing logic.
       * @enum {string}
       */
      scheme: "CUSTOM";
      /**
       * @description The fiat account the funds are being sent to.
       * @enum {string}
       */
      dstType: "FIAT_ACCOUNT";
      /** @description The ID of the fiat account the funds are being sent to. */
      dstId: string;
    };
    CustomCryptoRoutingDest: {
      /**
       * @description The network routing logic.
       * @enum {string}
       */
      scheme: "CUSTOM";
      /**
       * @description The type of destination account the funds are being sent to.
       * @enum {string}
       */
      dstType: "VAULT" | "EXCHANGE";
      /** @description The ID of the destination account the funds are being sent to. */
      dstId: string;
    };
    DefaultNetworkRoutingDest: {
      /**
       * @description The network routing logic.
       * @enum {string}
       */
      scheme: "DEFAULT";
    };
    NoneNetworkRoutingDest: {
      /**
       * @description No network routing logic.
       * @enum {string}
       */
      scheme: "NONE";
    };
    UserResponse: {
      id?: string;
      firstName?: string;
      lastName?: string;
      role?: string;
      email?: string;
      enabled?: boolean;
    };
    CreateUserGroupResponse: {
      id?: string;
      name?: string;
      memberIds?: string[];
      status?: string;
    };
    UserGroupResponse: {
      id?: string;
      name?: string;
      status?: string;
      memberIds?: string[];
    };
    UserGroupsResponse: components["schemas"]["UserGroupResponse"][];
    UserGroupCreateResponse: {
      name?: string;
      id?: string;
      memberIds?: string[];
      status?: string;
    };
    UserGroupCreateRequest: {
      groupName?: string;
      memberIds?: string[];
    };
    UserGroupUpdateRequest: {
      groupName?: string;
      memberIds?: string[];
    };
    SessionMetadata: {
      appUrl: string;
      appName?: string;
      appDescription?: string;
      appIcon?: string;
    };
    SessionDTO: {
      /**
       * @description Id of the connection
       * @example 4e9e7051-f3b2-48e9-8ee6-b12492552657
       */
      id: string;
      /** @description Id of the user that created the connection */
      userId: string;
      /** @description Metadata of the connection (provided by the dApp) */
      sessionMetadata: components["schemas"]["SessionMetadata"];
      /**
       * @description The vault to connect
       * @example 1
       */
      vaultAccountId: number;
      /**
       * @description The default fee level
       * @example MEDIUM
       * @enum {string}
       */
      feeLevel: "MEDIUM" | "HIGH";
      /**
       * @description The chains approved for the connection
       * @example [
       *   "ETH",
       *   "ETH_TEST",
       *   "SOL"
       * ]
       */
      chainIds: string[];
      /**
       * @description The connection's type
       * @example WalletConnect
       * @enum {string}
       */
      connectionType: "WalletConnect";
      /**
       * @description The method through which the connection was established
       * @example API
       * @enum {string}
       */
      connectionMethod: "DESKTOP" | "MOBILE" | "API";
      /**
       * Format: date-time
       * @description Timestamp of the session's creation
       */
      creationDate: string;
    };
    GetConnectionsResponse: {
      /** @description Array with the requested dApp connection's data */
      data: components["schemas"]["SessionDTO"][];
      paging?: components["schemas"]["Paging"];
    };
    CreateConnectionRequest: {
      /**
       * @description The ID of the vault to create a dApp.
       * @example 1
       */
      vaultAccountId: number;
      /**
       * @description The default fee level. Valid values are `MEDIUM` and `HIGH`.
       * @example MEDIUM
       * @enum {string}
       */
      feeLevel: "MEDIUM" | "HIGH";
      /**
       * @description The WalletConnect uri provided by the dApp.
       * @example wc:77752975-906f-48f5-b59f-047826ee947e@1?bridge=https%3A%2F%2F0.bridge.walletconnect.org&key=64be99adc6086b7a729b0ec8c7e1f174927ab92e84f5c6f9527050225344a637
       */
      uri: string;
      /**
       * @description The IDs of the blockchain networks used in the dApp connection.
       * @example [
       *   "ETH",
       *   "ETH_TEST"
       * ]
       */
      chainIds?: string[];
    };
    CreateNcwConnectionRequest: {
      /**
       * @description The ID of the Non-Custodial Wallet to connect to the dApp.
       * @example b8337f1d-bd61-4d6c-afc1-4c9d60aa2132
       */
      ncwId: string;
      /**
       * @description The NCW account ID to connect to the dApp.
       * @example 1
       */
      ncwAccountId: number;
      /**
       * @description The default fee level. Valid values are `MEDIUM` and `HIGH`.
       * @example MEDIUM
       * @enum {string}
       */
      feeLevel: "MEDIUM" | "HIGH";
      /**
       * @description The WalletConnect uri provided by the dApp.
       * @example wc:77752975-906f-48f5-b59f-047826ee947e@1?bridge=https%3A%2F%2F0.bridge.walletconnect.org&key=64be99adc6086b7a729b0ec8c7e1f174927ab92e84f5c6f9527050225344a637
       */
      uri: string;
      /**
       * @description The IDs of the blockchain networks used in the dApp connection.
       * @example [
       *   "ETH"
       * ]
       */
      chainIds?: string[];
    };
    CreateConnectionResponse: {
      /**
       * @description The ID of the dApp connection initiated.
       * @example 4e9e7051-f3b2-48e9-8ee6-b12492552657
       */
      id: string;
      /** @description Metadata of the dApp connection (provided by the dApp). */
      sessionMetadata: components["schemas"]["SessionMetadata"];
    };
    RespondToConnectionRequest: {
      /**
       * @description Approval of the initiated dApp connection.
       * @example true
       */
      approve: boolean;
    };
    AddCollateralRequestBody: {
      transactionRequest?: components["schemas"]["TransactionRequest"];
      /** @description optional */
      isSrcCollateral?: boolean;
    };
    RemoveCollateralRequestBody: {
      transactionRequest?: components["schemas"]["TransactionRequest"];
      /** @description optional */
      isDstCollateral?: boolean;
    };
    SettlementRequestBody: {
      mainExchangeAccountId?: string;
    };
    SettlementResponse: {
      id?: string;
      initiator?: string;
      exchangeReply?: string;
      fireblocksInitiatedTransactions?: Record<string, never>;
      exchangeRequestedTransactions?: components["schemas"]["SettlementResponse"];
    };
    GetSettlementResponse: components["schemas"]["SettlementResponse"];
    ToExchangeTransaction: {
      assetId?: string;
      amount?: string;
      dstAddress?: string;
      /** @description optional */
      dstTag?: string;
    };
    ToCollateralTransaction: {
      asset?: string;
      amount?: string;
      srcAddress?: string;
      /** @description optional */
      srcTag?: string;
      /** @description optional */
      fee?: string;
    };
    XBSettlementConfigCreationRequestBody: {
      /** @description The name for the cross-border settlement configuration */
      name: string;
      corridorId: components["schemas"]["XBSettlementCorridorId"];
      steps: components["schemas"]["XBSettlementConfigStepsRecord"];
      conversionSlippageBasisPoints?: components["schemas"]["XBSettlementConversionSlippageBasisPoints"];
    };
    XBSettlementConfigCreationResponse: components["schemas"]["XBSettlementConfigModel"];
    XBSettlementConfigEditRequestBody: {
      /** @description The name for the cross-border settlement configuration */
      name: string;
      steps: components["schemas"]["XBSettlementConfigStepsRecord"];
      conversionSlippageBasisPoints?: components["schemas"]["XBSettlementConversionSlippageBasisPoints"];
    };
    XBSettlementConfigEditResponse: components["schemas"]["XBSettlementConfigModel"];
    XBSettlementConfigDeletionResponse: components["schemas"]["XBSettlementConfigModel"];
    XBSettlementGetConfigResponse: components["schemas"]["XBSettlementConfigModel"];
    XBSettlementGetAllConfigsResponse: {
      configurations: components["schemas"]["XBSettlementConfigModel"][];
    };
    XBSettlementFlowExecutionRequestBody: {
      conversionSlippageBasisPoints?: components["schemas"]["XBSettlementConversionSlippageBasisPoints"];
    };
    XBSettlementFlowExecutionResponse: components["schemas"]["XBSettlementFlowExecutionModel"];
    XBSettlementFlowExecutionStep: {
      /** @description A unique id for the step execution */
      id: string;
      accountId: string;
      status: components["schemas"]["XBSettlementFlowExecutionStepStatus"];
      inputAmount: components["schemas"]["XBSettlementAsset"];
      outputAmount?: components["schemas"]["XBSettlementAsset"];
      fee?: components["schemas"]["XBSettlementAsset"];
      /** @description The step execution start time in epoch format. */
      startedAt?: number;
      /** @description The step execution end time in epoch format. */
      completedAt?: number;
      /** @description Whether or not signing is required for executing the step. */
      isSignRequired: boolean;
    };
    /** @enum {string} */
    XBSettlementFlowExecutionStepStatus: "NOT_STARTED" | "PROCESSING" | "COMPLETED" | "FAILED";
    /** @enum {string} */
    XBSettlementFlowExecutionStatus: "NOT_LAUNCHED" | "PROCESSING" | "COMPLETED" | "FAILED";
    /**
     * Format: uuid
     * @description Cross Bodrder configuraion unique id
     */
    XBSettlementConfigId: string;
    XBSettlementConfigModel: {
      configId: components["schemas"]["XBSettlementConfigId"];
      corridorId: components["schemas"]["XBSettlementCorridorId"];
      /** @description The name for the cross-border ettlement configuration */
      name: string;
      steps: components["schemas"]["XBSettlementConfigStepsRecord"];
      conversionSlippageBasisPoints: components["schemas"]["XBSettlementConversionSlippageBasisPoints"];
      /** @description The creation time in epoch format. */
      createdAt: number;
    };
    /**
     * @description - MX_US : Mexico (MXN) to USA (USD)
     * - CO_US : Colombia (COP) to USA (USD)
     * - US_MX : USA (USD) to Mexico (MXN)
     * - US_EU : USA (USD) to Europe Union (EUR)
     * - US_UK : USA (USD) to United Kingdon (GBP)
     *
     * @enum {string}
     */
    XBSettlementCorridorId: "MX_US" | "CO_US" | "US_MX" | "US_EU" | "US_UK";
    XBSettlementConfigStep: {
      stepType: components["schemas"]["XBSettlementStepType"];
      accountId: string;
    };
    /**
     * @description - ON_RAMP : A service that allows for the exchange of fiat currencies for cryptocurrencies. An OnRamp input value will always be fiat and output value crypto asset.
     * - VAULT_ACCOUNT : Fireblocks Vault account
     * - OFF_RAMP : A service that allows for the exchange of cryptocurrencies for fiat. An OffRamp input value will always be a crypto asset and output value be fiat.
     * - FIAT_DESTINATION : Fiat account
     *
     * @enum {string}
     */
    XBSettlementStepType: "ON_RAMP" | "VAULT_ACCOUNT" | "OFF_RAMP" | "FIAT_DESTINATION";
    XBSettlementFlowSetupStep: {
      accountId: string;
      inputAmount: components["schemas"]["XBSettlementAsset"];
      outputAmount: components["schemas"]["XBSettlementAsset"];
      estimatedFeeAmount: components["schemas"]["XBSettlementAsset"];
      /** @description The estimated time for executing the step. */
      estimatedTime: number;
      /** @description Whether or not signing is required for executing the step. */
      isSignRequired: boolean;
    };
    XBSettlementGetFlowResponse: {
      preview?: components["schemas"]["XBSettlementFlowPreviewModel"];
      execution?: components["schemas"]["XBSettlementFlowExecutionModel"];
    };
    XBSettlementFlowPreviewModel: {
      /** @description The unique id for the cross-border flow. */
      flowId: string;
      configId: components["schemas"]["XBSettlementConfigId"];
      /** @description The conversion rate received from the on-ramp or off-ramp. */
      conversionRate: string;
      inputAmount: components["schemas"]["XBSettlementAsset"];
      estimatedOutputAmount: components["schemas"]["XBSettlementAsset"];
      totalEstimatedFee: components["schemas"]["XBSettlementAsset"];
      /** @description The total *estimated* time for executing the cross-border flow. */
      totalEstimatedTime: number;
      steps: components["schemas"]["XBSettlementFlowStepsRecord"];
    };
    XBSettlementCreateFlowRequestBody: {
      configId: components["schemas"]["XBSettlementConfigId"];
      /** @description The amount to transfer in this cross-border flow. The type of asset is defined by the cross-border settlement configuration. */
      amount: string;
    };
    XBSettlementCreateFlowResponse: components["schemas"]["XBSettlementFlowPreviewModel"];
    XBSettlementFlowExecutionModel: {
      /** @description The unique id for the cross-border flow. */
      flowId: string;
      configId: components["schemas"]["XBSettlementConfigId"];
      inputAmount: components["schemas"]["XBSettlementAsset"];
      outputAmount: components["schemas"]["XBSettlementAsset"];
      totalFee: components["schemas"]["XBSettlementAsset"];
      /** @description The time the cross-border flow executed in epoch format. */
      initiatedAt: number;
      /** @description The id of the user which launched the flow */
      initiatedBy: string;
      state: components["schemas"]["XBSettlementFlowExecutionStatus"];
      steps: components["schemas"]["XBSettlementFlowStepsExecutionRecord"];
      /** @description Indicates the selected slippage used during the flow since override logic may have taken place. */
      selectedConversionSlippage: {
        basisPoints: number;
        reason: components["schemas"]["XBSettlementFlowSelectedConversionSlippageReason"];
      };
    };
    /** @enum {string} */
    XBSettlementFlowSelectedConversionSlippageReason: "DEFAULT" | "CONFIG" | "FLOW";
    XBSettlementFlowStepsExecutionRecord: {
      stepType?: components["schemas"]["XBSettlementStepType"];
      [key: string]: components["schemas"]["XBSettlementFlowExecutionStep"] | undefined;
    };
    XBSettlementConfigStepsRecord: {
      stepType?: components["schemas"]["XBSettlementStepType"];
      [key: string]: {
        accountId: string;
        inputAssetId?: components["schemas"]["XBSettlementAssetID"];
        outputAssetId?: components["schemas"]["XBSettlementAssetID"];
      } | undefined;
    };
    /**
     * @description Slippage configuarion in basis points, the default value is 10%
     *
     * @default 10000
     */
    XBSettlementConversionSlippageBasisPoints: number;
    XBSettlementFlowStepsRecord: {
      stepType?: components["schemas"]["XBSettlementStepType"];
      [key: string]: components["schemas"]["XBSettlementFlowSetupStep"] | undefined;
    };
    XBSettlementAsset: {
      amount: string;
      assetId?: components["schemas"]["XBSettlementAssetID"];
    };
    XBSettlementAssetID: components["schemas"]["XBSettlementFiatAsset"] | components["schemas"]["XBSettlementCryptoAsset"];
    /** @enum {string} */
    XBSettlementFiatAsset: "USD" | "MXN" | "COP" | "EUR" | "GBP";
    /**
     * @description - XLM_USDC_5F3T : USDC over Stellar network
     *
     * @enum {string}
     */
    XBSettlementCryptoAsset: "XLM_USDC_5F3T" | "XLM";
    CreatePayoutRequest: {
      paymentAccount: components["schemas"]["PaymentAccount"];
      instructionSet: components["schemas"]["PayoutInstruction"][];
    };
    PaymentAccount: {
      id: string;
      type: components["schemas"]["PaymentAccountType"];
    };
    PayoutInstruction: {
      id?: string;
      payeeAccount: components["schemas"]["PayeeAccount"];
      amount: components["schemas"]["InstructionAmount"];
    };
    /** @enum {string} */
    PaymentAccountType: "VAULT_ACCOUNT" | "EXCHANGE_ACCOUNT";
    PayeeAccount: {
      id: string;
      type: components["schemas"]["PayeeAccountType"];
    };
    InstructionAmount: {
      amount: string;
      assetId: string;
    };
    /**
     * @description - VAULT_ACCOUNT  	a native Fireblocks vault account
     * - EXCHANGE_ACCOUNT 	a third-party exchange account
     * - INTERNAL_WALLET 	a whitelisted address marked as internal to the workspace/organization
     * - EXTERNAL_WALLET	a whitelisted address marked as external
     * - NETWORK_CONNECTION	a member of the Fireblocks network
     * - FIAT_ACCOUNT	a third-party account of a fiat bank (Signature, BCB, etc)
     *
     * @enum {string}
     */
    PayeeAccountType: "VAULT_ACCOUNT" | "EXCHANGE_ACCOUNT" | "INTERNAL_WALLET" | "EXTERNAL_WALLET" | "NETWORK_CONNECTION" | "FIAT_ACCOUNT";
    PayoutResponse: {
      payoutId: string;
      paymentAccount: components["schemas"]["PaymentAccountResponse"];
      createdAt: number;
      state: components["schemas"]["PayoutState"];
      status: components["schemas"]["PayoutStatus"];
      /**
       * @description <ul>
       * <li> INSUFFICIENT_BALANCE</li>
       * <li> SOURCE_TRANSLATION</li>
       * <li> SOURCE_NOT_UNIQUE</li>
       * <li> SOURCE_NOT_FOUND</li>
       * <li> SOURCE_TYPE_NOT_SUPPORTED</li>
       * <li> EMPTY_SOURCE</li>
       * <li> DESTINATION_TRANSLATION</li>
       * <li> DESTINATION_NOT_UNIQUE</li>
       * <li> DESTINATION_NOT_FOUND</li>
       * <li> EMPTY_DESTINATION</li>
       * <li> PARSING </li>
       * <li> UNKNOWN</li>
       * <li> FIREBLOCKS_CLIENT</li>
       * <li> TRANSACTION_SUBMISSION</li>
       * </ul>
       */
      reasonOfFailure?: string;
      initMethod?: components["schemas"]["PayoutInitMethod"];
      instructionSet: components["schemas"]["PayoutInstructionResponse"][];
      reportUrl?: string;
    };
    PaymentAccountResponse: {
      id?: string;
      type?: components["schemas"]["PaymentAccountType"];
    };
    /**
     * @description - CREATED - payout instruction set created with all its details
     * - FILE_FOUND - new file found in the FTP
     * - REQUESTED - payout requested with all its details
     * - TRANSLATED - payout instruction account IDs identified and translated
     * - PROCESSING - payout instruction set executed and is processing
     * - SUBMITTED - transactions submitted for payout instructions
     * - FINALIZED - payout finished processing, all transactions processed successfully
     * - INSUFFICIENT_BALANCE - insufficient balance in the payment account (can be a temporary state)
     * - FAILED - one or more of the payout instructions failed
     *
     * @enum {string}
     */
    PayoutState: "CREATED" | "FILE_FOUND" | "REQUESTED" | "TRANSLATED" | "PROCESSING" | "SUBMITTED" | "FINALIZED" | "INSUFFICIENT_BALANCE" | "FAILED";
    /**
     * @description - REQUESTED	payout requested with all its details
     * - VERIFIED	payout instruction set details were verified
     * - PROCESSING	payout instruction set executed and is processing
     * - FINALIZED	payout done (all payout instructions completed successfully)
     * - INSUFFICIENT_BALANCE	insufficient balance in the payment account (can be a temporary state)
     * - FAILED	one or more of the payout instructions failed
     *
     * @enum {string}
     */
    PayoutStatus: "REGISTERED" | "VERIFYING" | "IN_PROGRESS" | "DONE" | "INSUFFICIENT_BALANCE" | "FAILED";
    /** @enum {string} */
    PayoutInitMethod: "FILE" | "API";
    PayoutInstructionResponse: {
      id?: string;
      payeeAccount: components["schemas"]["PayeeAccountResponse"];
      amount: components["schemas"]["InstructionAmount"];
      state: components["schemas"]["PayoutInstructionState"];
      transactions: components["schemas"]["Transaction"][];
    };
    PayeeAccountResponse: {
      id?: string;
      type?: components["schemas"]["PayeeAccountType"];
    };
    /**
     * @description - NOT_STARTED	- waiting to start
     * - TRANSACTION_SENT - an underlying transaction was sent
     * - COMPLETED	- completed successfully
     * - FAILED - failed
     * - TRANSLATION_ERROR -lookup of the destination failed (due to changes in the underlying whitelisted external wallet or similar)
     * - SKIPPED- no transaction(s) created for this instruction
     *
     * @enum {string}
     */
    PayoutInstructionState: "NOT_STARTED" | "TRANSACTION_SENT" | "COMPLETED" | "FAILED" | "TRANSLATION_ERROR" | "SKIPPED";
    Transaction: {
      id: string;
      /** @enum {string} */
      state: "SUBMITTED" | "QUEUED" | "PENDING_AUTHORIZATION" | "PENDING_SIGNATURE" | "BROADCASTING" | "PENDING_3RD_PARTY_MANUAL_APPROVAL" | "PENDING_3RD_PARTY" | "PENDING" | "CONFIRMING" | "CONFIRMED" | "COMPLETED" | "PARTIALLY_COMPLETED" | "PENDING_AML_SCREENING" | "CANCELLING" | "CANCELLED" | "REJECTED" | "BLOCKED" | "FAILED" | "TIMEOUT";
      /** Format: date-time */
      timestamp?: number;
      instructionId?: string;
    };
    DispatchPayoutResponse: {
      payoutId: string;
    };
    TravelRuleAddress: {
      /**
       * @description Street address
       * @example 1234 Example St
       */
      street: string;
      /**
       * @description City
       * @example New York
       */
      city: string;
      /**
       * @description State or province
       * @example NY
       */
      state: string;
      /**
       * @description Postal or ZIP code
       * @example 10001
       */
      postalCode: string;
    };
    TravelRuleValidateTransactionRequest: {
      /**
       * @description Transaction asset symbol BTC,ETH)
       * @example BTC
       */
      transactionAsset: string;
      /**
       * @description Transaction destination address
       * @example bc1qxy2kgdygjrsqtzq2n0yrf1234p83kkfjhx0wlh
       */
      destination: string;
      /**
       * @description Transaction amount in the transaction asset
       * @example 10
       */
      transactionAmount: string;
      /**
       * @description This is the identifier assigned to your VASP
       * @example did:ethr:0x44957e75d6ce4a5bf37aae117da86422c848f7c2
       */
      originatorVASPdid: string;
      /**
       * @description "True" if the originator and beneficiary is the same person and you therefore do not need to collect any information. "False" if it is a third-party transfer.
       * @example false
       */
      originatorEqualsBeneficiary: boolean;
      /**
       * @description This will also check if the transaction is a TRAVEL_RULE in the beneficiary VASP's jurisdiction
       * @example true
       */
      travelRuleBehavior: boolean;
      /**
       * @description This is the identifier assigned to the VASP the funds are being sent to
       * @example did:ethr:0x46a7ed5813ce735387df2bfb245bd7722e0de992
       */
      beneficiaryVASPdid: string;
      /**
       * @description Beneficiary VASP name
       * @example HelloCrypto
       */
      beneficiaryVASPname: string;
      /**
       * @description Beneficiary  name
       * @example John Doe
       */
      beneficiaryName: string;
      /**
       * @description Beneficiary  name
       * @example 1234-1234-1234-12234
       */
      beneficiaryAccountNumber: string;
      /**
       * @description Beneficiary  name
       * @example {"addressLine: [Wayne Manor, Gotham City, New York, USA]"}
       */
      beneficiaryAddress: components["schemas"]["TravelRuleAddress"];
    };
    TravelRuleValidateTransactionResponse: {
      /**
       * @description "isValid" will tell you if you have collected all the information needed for the travel rule data transfer. Once this field = "true", you can move on to the next step which is to transfer the front-end information to your back-end and perform Travel Rule Transaction create
       * @example true
       */
      isValid: boolean;
      /**
       * @description "type" will tell you if the virtual asset value converted to FIAT value of the withdrawal request is above (=TRAVELRULE) or below (=BELOW_THRESHOLD) the threshold in your jurisdiction. If it is to an unhosted wallet which does not require travel rule information to be sent and only collected, it will say NON_CUSTODIAL.
       * @example TRAVELRULE
       */
      type: string;
      /**
       * @description "beneficiaryAddressType" will tell you if your blockchain analytics provider or internal address book has been able to identify the wallet address.
       * @example UNKNOWN
       */
      beneficiaryAddressType: string;
      /**
       * @description "addressSource" will tell you if the address was found in your internal address book or identified by the blockchain analytics provider.
       * @example UNKNOWN
       */
      addressSource: string;
      /**
       * @description The VASP DID of the beneficiary VASP
       * @example did:ethr:0x46a7ed5813ce735387df2bfb245bd7722e0de992
       */
      beneficiaryVASPdid: string;
      /**
       * @description "beneficiaryVASPname" will tell you the name of the VASP that has been identified as the owner of the wallet address. This name is used in a subsequent call to get its DID.
       * @example Fireblocks
       */
      beneficiaryVASPname: string;
      /**
       * @description "errors/warnings" will tell you what information about the beneficiary you need to collect from the sender.
       * @example [
       *   "optional-beneficiaryAccountNumber"
       * ]
       */
      warnings: string[];
    };
    TravelRuleTransactionBlockchainInfo: {
      txHash: string;
      origin: string;
      destination: string;
    };
    TravelRulePiiIVMS: {
      fullName: string;
      dateOfBirth: string;
      placeOfBirth: string;
      address: string;
      identificationNumber: string;
      nationality: string;
      countryOfResidence: string;
      taxIdentificationNumber: string;
      customerNumber: string;
    };
    TravelRuleOwnershipProof: {
      /**
       * @description Type of ownership proof
       * @example passport
       */
      type: string;
      /**
       * @description Identification number
       * @example 123456789
       */
      id: string;
      /**
       * @description Name of owner
       * @example Alice
       */
      name: string;
      /**
       * @description Country of issuance
       * @example US
       */
      country: string;
      /**
       * @description Date of issuance
       * @example 2022-01-01
       */
      issueDate: string;
      /**
       * @description Name of issuing entity
       * @example US Government
       */
      issuer: string;
    };
    TravelRuleValidateFullTransactionRequest: {
      /** @description The asset involved in the transaction */
      transactionAsset: string;
      /** @description The amount of the transaction */
      transactionAmount: string;
      /** @description The DID of the transaction originator */
      originatorDid: string;
      /** @description The DID of the transaction beneficiary */
      beneficiaryDid: string;
      /** @description The VASP ID of the transaction originator */
      originatorVASPdid: string;
      /** @description The VASP ID of the transaction beneficiary */
      beneficiaryVASPdid: string;
      /** @description The name of the VASP acting as the beneficiary */
      beneficiaryVASPname: string;
      /** @description Information about the blockchain transaction */
      transactionBlockchainInfo: components["schemas"]["TravelRuleTransactionBlockchainInfo"];
      /** @description Information about the originator of the transaction */
      originator: components["schemas"]["TravelRulePiiIVMS"];
      /** @description Information about the beneficiary of the transaction */
      beneficiary: components["schemas"]["TravelRulePiiIVMS"];
      /** @description Encrypted data related to the transaction */
      encrypted: string;
      /** @description The protocol used to perform the travel rule */
      protocol: string;
      /** @description The email address where a notification should be sent upon completion of the travel rule */
      notificationEmail: string;
      /** @description Whether to skip validation of beneficiary data */
      skipBeneficiaryDataValidation: boolean;
      /** @description Whether to check if the transaction is a TRAVEL_RULE in the beneficiary VASP's jurisdiction */
      travelRuleBehavior: boolean;
      /** @description Ownership proof related to the originator of the transaction */
      originatorProof: components["schemas"]["TravelRuleOwnershipProof"];
      /** @description Ownership proof related to the beneficiary of the transaction */
      beneficiaryProof: components["schemas"]["TravelRuleOwnershipProof"];
      /** @description Personal identifiable information related to the transaction */
      pii: components["schemas"]["TravelRulePiiIVMS"];
    };
    TravelRuleIssuer: {
      issuerDid: string;
    };
    TravelRuleIssuers: {
      yearFounded: components["schemas"]["TravelRuleIssuer"];
      isRegulated: components["schemas"]["TravelRuleIssuer"];
      regulatoryAuthorities: components["schemas"]["TravelRuleIssuer"];
      name: components["schemas"]["TravelRuleIssuer"];
      logo: components["schemas"]["TravelRuleIssuer"];
      website: components["schemas"]["TravelRuleIssuer"];
      legalName: components["schemas"]["TravelRuleIssuer"];
      legalStructure: components["schemas"]["TravelRuleIssuer"];
      incorporationCountry: components["schemas"]["TravelRuleIssuer"];
      businessNumber: components["schemas"]["TravelRuleIssuer"];
      addressLine1: components["schemas"]["TravelRuleIssuer"];
      city: components["schemas"]["TravelRuleIssuer"];
      country: components["schemas"]["TravelRuleIssuer"];
      description: components["schemas"]["TravelRuleIssuer"];
    };
    TravelRuleVASP: {
      did: string;
      name: string;
      verificationStatus: string;
      addressLine1: string;
      addressLine2: string;
      city: string;
      country: string;
      emailDomains: string;
      website: string;
      logo: string;
      legalStructure: string;
      legalName: string;
      yearFounded: string;
      incorporationCountry: string;
      isRegulated: string;
      otherNames: string;
      identificationType: string;
      identificationCountry: string;
      businessNumber: string;
      regulatoryAuthorities: string;
      jurisdictions: string;
      street: string;
      number: string;
      unit: string;
      postCode: string;
      state: string;
      certificates: string;
      description: string;
      travelRule_OPENVASP: string;
      travelRule_SYGNA: string;
      travelRule_TRISA: string;
      travelRule_TRLIGHT: string;
      travelRule_EMAIL: string;
      travelRule_TRP: string;
      travelRule_SHYFT: string;
      travelRule_USTRAVELRULEWG: string;
      createdAt: string;
      createdBy: string;
      updatedAt: string;
      updatedBy: string;
      lastSentDate: string;
      lastReceivedDate: string;
      documents: string;
      hasAdmin: boolean;
      isNotifiable: boolean;
      issuers: components["schemas"]["TravelRuleIssuers"];
    };
    TravelRuleGetAllVASPsResponse: {
      vasps: components["schemas"]["TravelRuleVASP"][];
    };
    TravelRuleUpdateVASPDetails: {
      /**
       * @description The decentralized identifier of the VASP
       * @example did:ethr:0x44957e75d6ce4a5bf37aae117da86422c848f7c2
       */
      did: string;
      /**
       * @description The PII DID key of the VASP
       * @example did:key:z6Mks5CZRaiooKYhq5TwtXQC1gWhwiZnmiKfFrMnYY62MhYf
       */
      pii_didkey: string;
    };
    /**
     * @description * EXCHANGE - A third-party exchange account connected to your workspace
     * * UNMANAGED - A unmanaged wallet outside of Fireblocks workspace
     * * VAULT - An account in your Fireblocks Vault
     * * NETWORK_CONNECTION - A connection in your Fireblocks network
     * * COMPOUND - (deprecated) An asset retrieved by using the Compound DeFI protocol
     * * FIAT_ACCOUNT - A third-party fiat account connected to your workspace
     * * ONE_TIME_ADDRESS - A non-whitelisted asset from your Fireblocks Workspace
     * * "*" - All types
     *
     * @enum {string}
     */
    PolicySrcOrDestType: "EXCHANGE" | "UNMANAGED" | "VAULT" | "NETWORK_CONNECTION" | "COMPOUND" | "FIAT_ACCOUNT" | "ONE_TIME_ADDRESS" | "*";
    /**
     * @description * EXTERNAL - A whitelisted wallet assigned as external is typically used for addresses managed by your clients and counterparties
     * * INTERNAL - A whitelisted wallet assigned as internal, is typically used for addresses that you control outside of your Fireblocks workspace
     * * CONTRACT - A whitelisted wallet assigned as contract is for identifying and managing external smart contracts
     * * EXCHANGETEST - Exchanges which operate only on testnet assets
     * * "*" - All subtypes
     *
     * @enum {string}
     */
    PolicySrcOrDestSubType: "EXTERNAL" | "INTERNAL" | "CONTRACT" | "EXCHANGETEST" | "*";
    /**
     * @description Defines the account id, options are
     * * "*" - All accounts
     * * Specific account id
     */
    PolicySrcOrDestId: string;
    /**
     * @description * PER_SINGLE_MATCH - Apply the limit to each listed entity
     * * ACROSS_ALL_MATCHES - Apply the limit to the sum of all listed entities
     *
     * @enum {string}
     */
    AmountAggregationTimePeriodMethod: "PER_SINGLE_MATCH" | "ACROSS_ALL_MATCHES";
    /** @description Defines source or destination component with id attribute only */
    srcOrDestWithIdOnly: string[];
    /** @description Defines source or destination component with id and type attributes */
    srcOrDestWithIdAndType: ("EXCHANGE" | "UNMANAGED" | "VAULT" | "NETWORK_CONNECTION" | "COMPOUND" | "FIAT_ACCOUNT" | "ONE_TIME_ADDRESS" | "*")[];
    /** @description Defines source or destination component with id, type and subtype attributes */
    srcOrDestWithAllAttributes: ("EXCHANGE" | "UNMANAGED" | "VAULT" | "NETWORK_CONNECTION" | "COMPOUND" | "FIAT_ACCOUNT" | "ONE_TIME_ADDRESS" | "*" | {"$ref":"components[\"schemas\"][\"PolicySrcOrDestId\"]"} | {"$ref":"components[\"schemas\"][\"PolicySrcOrDestType\"]"} | {"$ref":"components[\"schemas\"][\"PolicySrcOrDestSubType\"]"})[];
    /** @description Policy rule which is enforced on transactions */
    PolicyRule: {
      /**
       * @deprecated
       * @description (deprecated - replaced by "operators")  | Defines users who can initiate the type of transaction to which the rule applies. options are * "*" - All users are allowed * Specific User id
       */
      operator?: string;
      /** @description Defines users/groups who can initiate the type of transaction to which the rule applies. */
      operators?: {
        /**
         * @description If used then this property should appear as the only child property
         * * "*" - All users are allowed
         *
         * @enum {string}
         */
        wildcard?: "*";
        /** @description Set of users ids */
        users?: string[];
        /** @description Set of group ids */
        usersGroups?: string[];
        /** @description set of services to initiate transactions */
        services?: string[];
      };
      /**
       * @description Defines the type of transaction to which the rule applies.
       *   * TRANSFER - Default. Transfers funds from one account to another
       *   * CONTRACT_CALL - Calls a smart contract, mainly for DeFi operations.
       *   * APPROVE - Allows a smart contract to withdraw from a designated wallet.
       *   * MINT - Perform a mint operation (increase supply) on a supported token
       *   * BURN - Perform a burn operation (reduce supply) on a supported token
       *   * SUPPLY - Use for DeFi to lend assets
       *   * REDEEM - Use for DeFi to get lending back
       *   * STAKE - Allows you to allocate and lock certain assets for earning staking rewards.
       *   * RAW - An off-chain message with no predefined format, use it to sign any message with your private key.
       *   * TYPED_MESSAGE - An off-chain message type that follows a predefined format, used to sign specific messages that are not actual transactions.
       *
       * @enum {string}
       */
      transactionType?: "TRANSFER" | "CONTRACT_CALL" | "APPROVE" | "MINT" | "BURN" | "SUPPLY" | "REDEEM" | "STAKE" | "RAW" | "TYPED_MESSAGE";
      /**
       * @deprecated
       * @description (deprecated - replaced by "designatedSigners") Id representing the user who signs transactions that match a specific rule
       */
      designatedSigner?: string;
      /** @description Set of ids representing the users who signs transactions that match a specific rule */
      designatedSigners?: {
        /** @description Set of users ids */
        users?: string[];
        /** @description Set of group ids */
        usersGroups?: string[];
      };
      /**
       * @description Policy rule type
       * @enum {string}
       */
      type: "TRANSFER";
      /**
       * @description Defines what occurs when a transaction meets the rule's criteria
       * * ALLOW - The transaction goes through and can be signed without requiring additional approvals
       * * BLOCK - The transaction is automatically blocked
       * * 2-TIER - Only these users or user groups can approve
       *            If any of them reject the transaction before the required approval threshold is met, the transaction doesn't go through
       *            The list of entities are set is "authorizationGroups" field
       *
       * @enum {string}
       */
      action: "ALLOW" | "BLOCK" | "2-TIER";
      /**
       * @description Defines the type of asset being transacted, options are
       * * "*" - All assets
       * * Specific asset
       */
      asset: string;
      /**
       * @deprecated
       * @description (deprecated - replaced by "src") source account type
       */
      srcType?: components["schemas"]["PolicySrcOrDestType"];
      /**
       * @deprecated
       * @description (deprecated - replaced by "src") source sub account type
       */
      srcSubType?: components["schemas"]["PolicySrcOrDestSubType"];
      /**
       * @deprecated
       * @description (deprecated - replaced by "src") source account id
       */
      srcId?: components["schemas"]["PolicySrcOrDestId"];
      /** @description Defines source accounts the rule allows transfers to originate from */
      src?: {
        /** @description A set of ids in a tuple format */
        ids?: (components["schemas"]["srcOrDestWithIdOnly"] | components["schemas"]["srcOrDestWithIdAndType"] | components["schemas"]["srcOrDestWithAllAttributes"])[];
      };
      /**
       * @deprecated
       * @description (deprecated - replaced by "dst") destination account type
       */
      dstType?: components["schemas"]["PolicySrcOrDestType"];
      /**
       * @deprecated
       * @description (deprecated - replaced by "dst") destination sub account type
       */
      dstSubType?: components["schemas"]["PolicySrcOrDestSubType"];
      /**
       * @deprecated
       * @description (deprecated - replaced by "dst") destination account id
       */
      dstId?: components["schemas"]["PolicySrcOrDestId"];
      /** @description Defines the destination accounts the rule allows transfers to */
      dst?: {
        /** @description A set of ids in a tuple format */
        ids?: (components["schemas"]["srcOrDestWithIdOnly"] | components["schemas"]["srcOrDestWithIdAndType"] | components["schemas"]["srcOrDestWithAllAttributes"])[];
      };
      /**
       * @description Defines whether the destination to which you are sending funds must be whitelisted, to allow one-time transfers to non-whitelisted external addresses, or both.
       * By default, you can only transfer to an external address after it’s whitelisted.
       *   * WHITELISTED - Can only be sent to whitelisted addresses.
       *   * ONE_TIME - Can only be sent to non-whitelisted external addresses.
       *   * "*" - can be sent to whitelisted addresses or non-whitelisted external
       *
       * @enum {string}
       */
      dstAddressType?: "WHITELISTED" | "ONE_TIME" | "*";
      /**
       * @description * USD - Limits the amount of any asset users can transfer based on the USD equivalent of the asset.
       * * EUR - Limits the amount of any asset users can transfer based on the EURO equivalent of the asset.
       * * NATIVE - Limits the amount of an asset a user can transfer when using a specific asset.
       *
       * @enum {string}
       */
      amountCurrency: "USD" | "EUR" | "NATIVE";
      /**
       * @description * SINGLE_TX - limit applies to a single transaction
       * * TIMEFRAME - limit applies to all transactions within the defined time period
       *
       * @enum {string}
       */
      amountScope: "SINGLE_TX" | "TIMEFRAME";
      /** @description Defines the value a transaction must exceed for the rule to apply to it (according to the amountCurrency field) */
      amount: string | number;
      /**
       * @description Time period in seconds applied by the amountScope field to accumulate transferred amounts in transactions that match the rule, until the total exceeds the value you specify under Minimum.
       * When the specified amount is reached within that period, whether by one or many transactions, further transactions in that period either fail or require more approvals.
       */
      periodSec: number;
      /**
       * @deprecated
       * @description (deprecated - replaced by "authorizationGroups") Allowed entities which can approves a transaction
       */
      authorizers?: string[];
      /**
       * @deprecated
       * @description (deprecated - replaced by "authorizationGroups") Min amount of entities which are needed to approve a transaction
       */
      authorizersCount?: number;
      /** @description Defines the transaction approval terms */
      authorizationGroups?: {
        /**
         * @description * AND - requires approval of all authorization groups
         * * OR - requires approval of at least one of the authorization groups
         *
         * @enum {string}
         */
        logic?: "AND" | "OR";
        /** @description Defines whether the user who initiates a transaction can approve their own transaction and count toward the approval threshold for their transaction */
        allowOperatorAsAuthorizer?: boolean;
        /** @description Groups of entities which can approve the transaction */
        groups?: {
            /** @description User ids */
            users?: string[];
            /** @description Group ids */
            usersGroups?: string[];
            /** @description Represents the min amount of entities which are required to approve the transaction, default is 1. */
            th?: number;
          }[];
      };
      /**
       * @description Defines the method by which the Policy Engine calculates accumulation.
       * It uses the Initiator, Source, and Destination to calculate accumulation toward the value under Minimum, for the time under Time Period.
       */
      amountAggregation?: {
        operators?: components["schemas"]["AmountAggregationTimePeriodMethod"];
        srcTransferPeers?: components["schemas"]["AmountAggregationTimePeriodMethod"];
        dstTransferPeers?: components["schemas"]["AmountAggregationTimePeriodMethod"];
      };
      /** @description Raw message signing configuration */
      rawMessageSigning?: {
        algorithm?: string;
        derivationPath?: {
          path?: number[];
        };
      };
      /** @description Applying this rule over APPROVE type transactions (can only be enabled when rule's transaction type is TRANSFER) */
      applyForApprove?: boolean;
      /** @description Applying this rule over TYPED_MESSAGE type transactions (can only be enabled when rule's transaction type is CONTRACT_CALL) */
      applyForTypedMessage?: boolean;
      /** @description A unique id identifying the rule */
      externalDescriptor: string;
    };
    /** @description Response object of the publish policy operation */
    PublishResult: {
      status: components["schemas"]["PolicyStatus"];
      rules: components["schemas"]["PolicyRule"][];
      checkResult: components["schemas"]["PolicyCheckResult"];
      metadata: components["schemas"]["PolicyMetadata"];
    };
    CreateConsoleUser: {
      firstName: string;
      lastName: string;
      role: string;
      email: string;
    };
    CreateAPIUser: {
      /** @description User role */
      role: string;
      /** @description users name */
      name: string;
      /** @description only for user with signing capabilities */
      csrPem?: string;
      /** @description cosigner setup type */
      coSignerSetupType?: string;
      /** @description is first? */
      coSignerSetupIsFirstUser?: boolean;
    };
    /**
     * @description * SUCCESS - success
     * * UNVALIDATED - not validated yet
     * * INVALID_CONFIGURATION - at least one rule is invalid
     * * PENDING - pending approval
     * * PENDING_CONSOLE_APPROVAL - pending approval from the console app
     * * AWAITING_QUORUM - pending quorum approval
     * * UNHANDLED_ERROR - unhandled error
     *
     * @enum {string}
     */
    PolicyStatus: "SUCCESS" | "UNVALIDATED" | "INVALID_CONFIGURATION" | "PENDING" | "PENDING_CONSOLE_APPROVAL" | "AWAITING_QUORUM" | "UNHANDLED_ERROR";
    /** @description Policy related metadata */
    PolicyMetadata: {
      /** @description The user id of the user who last edited the policy */
      editedBy?: string;
      /** @description The timestamp of the last edit of the policy */
      editedAt?: string;
      /** @description The user id of the user who last published the policy */
      publishedBy?: string;
      /** @description The timestamp of the last publish of the policy */
      publishedAt?: string;
    };
    /** @description Policy rules validation result */
    PolicyCheckResult: {
      /** @description Number of errors */
      errors: number;
      /** @description A set of validation results */
      result: components["schemas"]["PolicyRuleCheckResult"][];
    };
    /** @description The rule validation result */
    PolicyRuleCheckResult: {
      /** @description Rule index number in the policy */
      index: number;
      /**
       * @description Validation status
       * @enum {string}
       */
      status: "ok" | "failure";
      /** @description A set of rule validation error objects */
      errors: components["schemas"]["PolicyRuleError"][];
    };
    /** @description Rule validation result error */
    PolicyRuleError: {
      /** @description Error message */
      errorMessage: string;
      /** @description error code */
      errorCode: number;
      /** @description error code name */
      errorCodeName: string;
      /**
       * @description The field which the error relates to
       * * operator - transaction initiator
       * * operators - transaction initiators
       * * authorizationGroups - transaction authorizer groups
       * * designatedSigner - transaction signer
       * * designatedSigners - transaction signers
       * * contractMethods - contract methods
       * * amountAggregation - transaction amount aggregation configuration
       * * src - transaction source asset configuration
       * * dst - transaction destination asset configuration
       *
       * @enum {string}
       */
      errorField: "operator" | "operators" | "authorizationGroups" | "designatedSigner" | "designatedSigners" | "contractMethods" | "amountAggregation" | "src" | "dst";
    };
    /** @description Draft validation */
    DraftReviewAndValidationResponse: {
      draftResponse: components["schemas"]["DraftResponse"];
      validation: components["schemas"]["PolicyValidation"];
    };
    /** @description Policy validation */
    PolicyAndValidationResponse: {
      policy: components["schemas"]["PolicyResponse"];
      validation: components["schemas"]["PolicyValidation"];
    };
    /** @description Response object for draft operations */
    DraftResponse: {
      /** @description Operation status */
      status: string;
      /** @description Draft rules */
      rules: components["schemas"]["PolicyRule"][];
      /** @description Draft unique id */
      draftId: string;
      metadata: components["schemas"]["PolicyMetadata"];
    };
    /** @description Response object for policy operations */
    PolicyResponse: {
      /** @description A set of policy rules */
      rules: components["schemas"]["PolicyRule"][];
      metadata: components["schemas"]["PolicyMetadata"];
    };
    /** @description Policy validation object */
    PolicyValidation: {
      /** @description Validation status */
      status: string;
      checkResult: components["schemas"]["PolicyCheckResult"];
    };
    ErrorResponse: {
      error: {
        /** @enum {string} */
        type: "INTERNAL" | "AUTHENTICATION" | "AUTHORIZATION" | "VALIDATION" | "NOT_FOUND" | "UNPROCESSABLE_ENTITY" | "FORBIDDEN";
        message: string;
      };
    };
    SmartTransferForbiddenResponse: {
      /**
       * @description Forbidden error code
       * @example You do not have permission to execute this action
       */
      message: string;
      /**
       * @description Error code
       * @example 3002
       */
      code: string;
    };
    SmartTransferBadRequestResponse: {
      /**
       * @description Bad request error message
       * @example Your request contains invalid data
       */
      message: string;
      /**
       * @description Bad request error code
       * @example 2e7a7a5d-c85c-4ea5-9adf-668cba8b4eb4
       */
      code: string;
    };
    SmartTransferTicketResponseDto: {
      /**
       * @description Result message
       * @example Success
       */
      message: string | null;
      /** @description Data object with result data */
      data?: components["schemas"]["SmartTransferTicketDto"] | null;
    };
    SmartTransferTicketTermResponseDto: {
      /**
       * @description Result message
       * @example Success
       */
      message: string | null;
      /** @description Data object with result data */
      data?: components["schemas"]["SmartTransferTicketTermDto"] | null;
    };
    SmartTransferCreateTicketTermDto: {
      /**
       * @description Asset name
       * @example BTC
       */
      asset: string;
      /**
       * @description Amount
       * @example 133.789161216184
       */
      amount: number;
      /**
       * @description Identifier of the origination Network Profile
       * @example 947c6115-1f5f-4fb4-9fd6-a1f9dee14670
       */
      fromNetworkId: string;
      /**
       * @description Identifier of the destination Network Profile
       * @example 5d009697-c29b-48e0-aff8-1f4305d19dc2
       */
      toNetworkId: string;
    };
    SmartTransferTicketTermDto: {
      /**
       * @description Unique id of Smart Transfer ticket term
       * @example 84601ee2-b10f-4aa8-be9c-dba259a3533a
       */
      id: string;
      /**
       * @description Unique id of Smart Transfer ticket
       * @example 900f04c3-83bc-428d-b681-aef682059637
       */
      ticketId: string;
      /**
       * @description Asset name
       * @example BTC
       */
      asset: string;
      /**
       * @description Amount
       * @example 133.789161216184
       */
      amount: number;
      /**
       * @description Identifier of the origination Network Profile
       * @example 947c6115-1f5f-4fb4-9fd6-a1f9dee14670
       */
      fromNetworkId: string;
      /**
       * @description Source network name
       * @example Source network profile name
       */
      fromNetworkIdName: string;
      /**
       * @description Identifier of the destination Network Profile
       * @example 5d009697-c29b-48e0-aff8-1f4305d19dc2
       */
      toNetworkId: string;
      /**
       * @description Destination network name
       * @example Destination network profile name
       */
      toNetworkIdName: string;
      /**
       * @description Blockchain TX hash
       * @example 0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c
       */
      txHash: string | null;
      /**
       * @description Fireblocks transaction ID. It is set when the funding transaction is created.
       * @example 79075e8c-1fd9-4c97-9575-3bd9229e5c0d
       */
      fbTxId: string | null;
      /**
       * @description Ticket term transaction status
       * @example COMPLETED
       * @enum {string|null}
       */
      txStatus: "queued" | "submitted" | "pendingSignature" | "pendingAuthorization" | "broadcasting" | "confirming" | "pendingAmlScreening" | "completed" | "cancelled" | "failed" | "rejected" | "blocked" | "thirdPartyPendingManualApproval" | "thirdPartyPending" | "partiallyCompleted" | "cancelling" | null;
      /**
       * @description Ticket term status
       * @example CREATED
       * @enum {string}
       */
      status: "CREATED" | "FUNDING" | "FUNDING_FAILED" | "FUNDED" | "REJECTED";
      /**
       * Format: date-time
       * @description Date and time when the term is created.
       * @example 2023-03-01T11:23:00Z
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Date and time of last term update.
       * @example 2023-03-01T11:23:00Z
       */
      updatedAt: string;
    };
    SmartTransferCreateTicketDto: {
      createdByNetworkId: string;
      /** @enum {string} */
      type: "ASYNC";
      /** @description Number of hours after which an OPEN ticket will expire if no term is funded. */
      expiresIn?: number;
      terms?: components["schemas"]["SmartTransferCreateTicketTermDto"][];
      externalRefId?: string;
      note?: string;
      submit?: boolean;
    };
    SmartTransferTicketFilteredResponseDto: {
      /**
       * @description Result message
       * @example Success
       */
      message: string | null;
      /**
       * @description Returns last skipped id if any preceding elements are skipped in result.
       * @example 118320d2-761f-46c7-96cf-65e71a370b36
       */
      after: string;
      /** @description Result that match given query criteria */
      data: components["schemas"]["SmartTransferTicketDto"][];
    };
    SmartTransferTicketDto: {
      /**
       * @description Unique id of Smart Transfer ticket
       * @example 118320d2-761f-46c7-96cf-65e71a370b36
       */
      id: string;
      /**
       * @description Kind of Smart Transfer. Can be either `ASYNC` or `ATOMIC`
       * @example ASYNC
       * @enum {string}
       */
      type: "ASYNC";
      /**
       * @description Direction of Smart Transfer.
       * @example EXCHANGE
       * @enum {string}
       */
      direction?: "EXCHANGE" | "SEND" | "RECEIVE" | "INTERMEDIATE";
      /**
       * @description Current status of Smart Transfer ticket
       * @example DRAFT
       * @enum {string}
       */
      status: "DRAFT" | "PENDING_APPROVAL" | "OPEN" | "IN_SETTLEMENT" | "FULFILLED" | "EXPIRED" | "CANCELED";
      /**
       * @description Ticket terms (legs)
       * @example [
       *   {
       *     "id": "84601ee2-b10f-4aa8-be9c-dba259a3533a",
       *     "ticketId": "118320d2-761f-46c7-96cf-65e71a370b36",
       *     "amount": "10.00",
       *     "asset": "ETH",
       *     "fromNetworkId": "947c6115-1f5f-4fb4-9fd6-a1f9dee14670",
       *     "toNetworkId": "5d009697-c29b-48e0-aff8-1f4305d19dc2",
       *     "status": "CREATED"
       *   },
       *   {
       *     "id": "84601ee2-b10f-4aa8-be9c-dba259a3533a",
       *     "ticketId": "118320d2-761f-46c7-96cf-65e71a370b36",
       *     "amount": "10.00",
       *     "asset": "ETH",
       *     "fromNetworkId": "947c6115-1f5f-4fb4-9fd6-a1f9dee14670",
       *     "fromNetworkIdName": "Source network profile 1",
       *     "toNetworkId": "5d009697-c29b-48e0-aff8-1f4305d19dc2",
       *     "toNetworkIdName": "Destination network profile 1",
       *     "status": "FUNDING",
       *     "connectionId": "14817440-d5c8-4dbd-a754-ad415683610c",
       *     "fbTxId": "79075e8c-1fd9-4c97-9575-3bd9229e5c0d",
       *     "createdAt": "2023-03-01T11:23:00.000Z",
       *     "updatedAt": "2023-03-01T11:23:00.000Z"
       *   },
       *   {
       *     "id": "84601ee2-b10f-4aa8-be9c-dba259a3533a",
       *     "ticketId": "118320d2-761f-46c7-96cf-65e71a370b36",
       *     "amount": "10.00",
       *     "asset": "ETH",
       *     "fromNetworkId": "947c6115-1f5f-4fb4-9fd6-a1f9dee14670",
       *     "fromNetworkIdName": "Source network profile 2",
       *     "toNetworkId": "5d009697-c29b-48e0-aff8-1f4305d19dc2",
       *     "toNetworkIdName": "Destination network profile 2",
       *     "status": "FUNDED",
       *     "connectionId": "14817440-d5c8-4dbd-a754-ad415683610c",
       *     "fbTxId": "79075e8c-1fd9-4c97-9575-3bd9229e5c0d",
       *     "txHash": "0xb5c8bd9430b6cc87a0e2fe110ece6bf527fa4f170a4bc8cd032f768fc5219838",
       *     "createdAt": "2023-03-01T11:23:00.000Z",
       *     "updatedAt": "2023-03-01T11:23:00.000Z"
       *   }
       * ]
       */
      terms?: components["schemas"]["SmartTransferTicketTermDto"][];
      /**
       * @description Number of hours for expiration.This data is valid only it ticket not in DRAFT state and it will be used to calculate expiresAt value
       * @example 13
       */
      expiresIn?: number;
      /**
       * Format: date-time
       * @description Date and time at which the ticket will expire if no funding is performed.
       * @example 2023-03-01T11:23:00Z
       */
      expiresAt?: string;
      /**
       * Format: date-time
       * @description Date and time when ticket is submitted.
       * @example 2023-03-01T11:23:00Z
       */
      submittedAt?: string;
      /**
       * Format: date-time
       * @description Date and time when ticket is expired.
       * @example 2023-03-01T11:23:00Z
       */
      expiredAt?: string;
      /**
       * Format: date-time
       * @description Date and time when ticket is canceled.
       * @example 2023-03-01T11:23:00Z
       */
      canceledAt?: string;
      /**
       * Format: date-time
       * @description Date and time when ticket is fulfilled.
       * @example 2023-03-01T11:23:00Z
       */
      fulfilledAt?: string;
      /**
       * @description External Ref ID for Smart Transfer ticket.
       * @example 2631ffb9d8fe47c6b0825b5be28297da
       */
      externalRefId?: string;
      /**
       * @description Note
       * @example Random note
       */
      note?: string;
      /**
       * @description ID of network profile that created ticket
       * @example 3eaa94c5-128b-4835-bb08-3111bb6564c7
       */
      createdByNetworkId: string;
      /**
       * @description Name of network profile that created ticket
       * @example Network id name
       */
      createdByNetworkIdName: string;
      /**
       * @description Name of network profile that canceled ticket
       * @example Network id name
       */
      canceledByNetworkIdName?: string;
      /**
       * Format: date-time
       * @description Date and time at which the ticket is created.
       * @example 2023-03-01T11:23:00Z
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Date and time of last ticket update.
       * @example 2023-03-01T11:23:00Z
       */
      updatedAt: string;
      canceledByMe?: boolean;
      createdByMe?: boolean;
    };
    SmartTransferNotFoundResponse: {
      /**
       * @description Not found error message
       * @example Requested entity not found
       */
      message: string;
      /**
       * @description Error code
       * @example c943bdb8-ada0-4ba6-8645-74fcf188a10f
       */
      code: string;
    };
    SmartTransferSetTicketExpirationDto: {
      /** @description Sets ticket expiration time (in hours) after a ticket is submitted. If no funding source is set to any term, the ticket will automatically expire after given time. */
      expiresIn: number;
    };
    SmartTransferSetTicketExternalIdDto: {
      /** @description Each workspace can set their own external id they want to refer to this Ticket */
      externalRefId: string;
    };
    SmartTransferSubmitTicketDto: {
      /** @description Sets the ticket expiration time (in hours) after the ticket is submitted. If no funding source is set for any term, the ticket will automatically expire after given time. */
      expiresIn: number;
    };
    SmartTransferUpdateTicketTermDto: {
      /**
       * @description Asset name
       * @example BTC
       */
      asset: string;
      /**
       * @description Amount
       * @example 133.789161216184
       */
      amount: number;
      /**
       * @description Identifier of the origination Network Profile
       * @example 947c6115-1f5f-4fb4-9fd6-a1f9dee14670
       */
      fromNetworkId: string;
      /**
       * @description Identifier of the destination Network Profile
       * @example 5d009697-c29b-48e0-aff8-1f4305d19dc2
       */
      toNetworkId: string;
    };
    SmartTransferFundTermDto: {
      /**
       * @description Asset name
       * @example BTC
       */
      asset: string;
      /**
       * @description Amount
       * @example 133.789161216184
       */
      amount: string;
      /**
       * @description Id of the network connection used.
       * @example 0805153d-e77d-4f9b-8818-e507eeb2d122
       */
      networkConnectionId: string;
      /**
       * @description Id of the vault that is used as the source of the asset.
       * @example 2
       */
      srcId: string;
      /**
       * @description Source of the asset.
       * @example VAULT_ACCOUNT
       */
      srcType: string;
      /**
       * @description Transaction fee
       * @example 0.001
       */
      fee?: string;
      /**
       * @description Transaction fee level.
       * @example MEDIUM
       */
      feeLevel?: string;
    };
    SmartTransferManuallyFundTermDto: {
      txHash: string;
    };
    SmartTransferUserGroupsResponseDto: {
      /**
       * @description Result message
       * @example Success
       */
      message: string | null;
      /** @description Data object with result data */
      data?: components["schemas"]["SmartTransferUserGroupsDto"] | null;
    };
    SmartTransferUserGroupsDto: {
      /** @description Data object with result data */
      userGroupIds: string[] | null;
    };
    SmartTransferSetUserGroupsDto: {
      userGroupIds: string[];
    };
    JobCreated: {
      jobId?: string;
    };
    Task: {
      id?: string;
      jobId?: string;
      type?: string;
      tenantId?: string;
      created?: number;
      updated?: number;
      state?: string;
    };
    Tasks: components["schemas"]["Task"][];
    Job: {
      id?: string;
      tenantId?: string;
      type?: string;
      userId?: string;
      created?: number;
      updated?: number;
      state?: string;
      tasks?: components["schemas"]["Task"][];
    };
    Jobs: components["schemas"]["Job"][];
    AdditionalInfoDto: {
      /**
       * @description The estimated annual reward rate for the blockchain, represented as a decimal percentage value.
       * @example 6.48
       */
      estimatedAnnualReward: number;
      /**
       * @description The duration of the lockup period for certain actions on the blockchain, measured in milliseconds.
       * @example 172800000
       */
      lockupPeriod: number;
      /**
       * @description The duration of the activation period for certain actions on the blockchain, measured in milliseconds.
       * @example 172800000
       */
      activationPeriod: number;
    };
    ChainInfoResponseDto: {
      /**
       * @description The protocol identifier (e.g. "ETH"/"SOL").
       * @example SOL
       */
      chainDescriptor: string;
      /**
       * @description The current epoch number of the blockchain network.
       * @example 483
       */
      currentEpoch: number;
      /**
       * @description The percentage of time that has elapsed within the current epoch, represented as a decimal value between 0 and 1.
       * @example 0.31
       */
      epochElapsed: number;
      /**
       * @description The total duration in milliseconds of a single epoch.
       * @example 172800000
       */
      epochDuration: number;
      /** @description Additional information related to the blockchain. This may include extra details about the blockchain network. */
      additionalInfo: components["schemas"]["AdditionalInfoDto"];
    };
    StakeRequestDto: {
      /**
       * @description The source vault account to stake from
       * @example 22
       */
      vaultAccountId: string;
      /**
       * @description The ID of the provider
       * @example kiln
       */
      providerId: string;
      /**
       * @description Amount of tokens to stake
       * @example 32
       */
      stakeAmount: string;
      /**
       * @description The note to associate with the stake transactions.
       * @example stake request id CcaHc2L43ZWjwCHART3oZoJvHLAe9hzT2DJNUpBzoTN1 of 32ETH created on 02.04.23
       */
      txNote?: string;
      /**
       * @description Represents the fee for a transaction, which can be specified as a percentage value. Only one of fee/feeLevel is required.
       * @example 7
       */
      fee?: string;
      /**
       * @description Represents the fee level for a transaction, which can be set as slow, medium, or fast. Only one of fee/feeLevel is required.
       * @example MEDIUM
       */
      feeLevel?: string;
    };
    UnstakeRequestDto: {
      /**
       * @description id of position to unstake
       * @example b70701f4-d7b1-4795-a8ee-b09cdb5b850d
       */
      id: string;
      /**
       * @description Represents the fee for a transaction, which can be specified as a percentage value. Only one of fee/feeLevel is required.
       * @example 7
       */
      fee?: string;
      /**
       * @description Represents the fee level for a transaction, which can be set as slow, medium, or fast. Only one of fee/feeLevel is required.
       * @example MEDIUM
       */
      feeLevel?: string;
      /**
       * @description The note to associate with the transactions.
       * @example unstake request id b70701f4-d7b1-4795-a8ee-b09cdb5b850d #ETH
       */
      txNote?: string;
    };
    WithdrawRequestDto: {
      /**
       * @description id of position to withdraw
       * @example b70701f4-d7b1-4795-a8ee-b09cdb5b850d
       */
      id: string;
      /**
       * @description Represents the fee for a transaction, which can be specified as a percentage value. Only one of fee/feeLevel is required.
       * @example 7
       */
      fee?: string;
      /**
       * @description Represents the fee level for a transaction, which can be set as slow, medium, or fast. Only one of fee/feeLevel is required.
       * @example MEDIUM
       */
      feeLevel?: string;
      /**
       * @description The note to associate with the transactions.
       * @example withdraw request id b70701f4-d7b1-4795-a8ee-b09cdb5b850d #ETH
       */
      txNote?: string;
    };
    StakeResponseDto: {
      /**
       * @description The unique identifier of the staking position
       * @example b70701f4-d7b1-4795-a8ee-b09cdb5b850d
       */
      id: string;
    };
    UnstakeResponseDto: Record<string, never>;
    WithdrawResponseDto: Record<string, never>;
    RelatedTransactionDto: {
      /**
       * @description The transaction ID
       * @example b70601f4-d7b1-4795-a8ee-b09cdb4r850d
       */
      txId: string;
      /**
       * @description Is the transaction completed or not
       * @example true
       */
      completed: boolean;
    };
    SolanaBlockchainDataDto: {
      /**
       * @description The stake account address matching the stakeAccountId.
       * @example 3Ru67FyzMTcdENmmRL4Eve4dtPd6AdpuypR21q5EQCdq
       */
      stakeAccountAddress: string;
    };
    DelegationDto: {
      /**
       * @description The unique identifier of the staking position
       * @example b70701f4-d7b1-4795-a8ee-b09cdb5b850d
       */
      id: string;
      /**
       * @description The source vault account to stake from
       * @example 2
       */
      vaultAccountId: string;
      /**
       * @description The destination validator address name
       * @example FwR3P......tT59f
       */
      validatorName: string;
      /**
       * @description The destination validator provider name
       * @example Kiln
       */
      providerName: string;
      /**
       * @description The protocol identifier (e.g. "ETH"/ "SOL") to use
       * @example SOL
       */
      chainDescriptor: string;
      /**
       * @description Amount of tokens to stake, measured in the staked asset unit.
       * @example 0.05
       */
      amount: string;
      /**
       * @description The amount staked in the position, measured in the staked asset unit.
       * @example 0.000856038
       */
      rewardsAmount: string;
      /**
       * @description When was the request made (ISO Date).
       * @example 2023-07-13T15:55:34.256Z
       */
      dateCreated: string;
      /**
       * @description The current status.
       * @example active
       */
      status: string;
      /**
       * @description An array of transaction objects related to this position. Each object includes a 'txId' representing the transaction ID and a 'completed' boolean indicating if the transaction was completed.
       * @example [
       *   {
       *     "txId": "b70601f4-d7b1-4795-a8ee-b09cdb4r850d",
       *     "completed": true
       *   },
       *   {
       *     "txId": "c80601f4-d7b1-4795-a8ee-b09cdb5b450c",
       *     "completed": false
       *   }
       * ]
       */
      relatedTransactions: components["schemas"]["RelatedTransactionDto"][];
      /**
       * @description The destination address of the staking transaction.
       * @example FwR3PbjS5iyqzLiLugrBqKSa5EKZ4vK9SKs7eQXtT59f
       */
      validatorAddress: string;
      /**
       * @description The unique identifier of the staking provider
       * @example kiln
       */
      providerId: string;
      /**
       * @description An array of available actions that can be performed. for example, actions like "unstake" or "withdraw".
       * @example [
       *   "unstake"
       * ]
       */
      availableActions: string[];
      /**
       * @description Indicates whether there is an ongoing action for this position (true if ongoing, false if not).
       * @example true
       */
      inProgress: boolean;
      /**
       * @description The transaction ID of the ongoing request
       * @example c80601f4-d7b1-4795-a8ee-b09cdb5b450c
       */
      inProgressTxId?: string;
      /**
       * @description Additional fields per blockchain - can be empty or missing if not initialized or no additional info exists. The type depends on the chainDescriptor value. For Solana (SOL), stake account address. For Ethereum (ETH), an empty object is returned as no specific data is available.
       * @example {
       *   "stakeAccountAddress": "3Ru67FyzMTcdENmmRL4Eve4dtPd6AdpuypR21q5EQCdq"
       * }
       */
      blockchainPositionInfo: components["schemas"]["SolanaBlockchainDataDto"];
    };
    amountAndChainDescriptor: {
      /**
       * @description The protocol identifier (e.g. "ETH"/"SOL") for summary
       * @example ETH
       */
      chainDescriptor: string;
      /**
       * @description Cryptocurrency quantity
       * @example 32.007149606
       */
      amount: string;
    };
    DelegationSummaryDto: {
      /** @description An array of objects containing chain descriptors and associated amounts, representing active positions. */
      active: components["schemas"]["amountAndChainDescriptor"][];
      /** @description An array of objects containing chain descriptors and associated amounts, representing inactive positions. */
      inactive: components["schemas"]["amountAndChainDescriptor"][];
      /** @description An array of objects containing chain descriptors and associated amounts, representing rewards positions. */
      rewardsAmount: components["schemas"]["amountAndChainDescriptor"][];
      /** @description An array of objects with chain descriptors and total staked amounts, representing the combined staked totals of active and inactive positions. */
      totalStaked: components["schemas"]["amountAndChainDescriptor"][];
    };
    ValidatorDto: {
      /**
       * @description The protocol identifier (e.g. "ETH"/"SOL") of the validator
       * @example SOL
       */
      chainDescriptor: string;
      /**
       * @description The service fee as a percentage out of the earned rewards
       * @example 5
       */
      feePercent: number;
    };
    ProviderDto: {
      /**
       * @description The ID of the provider
       * @example kiln
       */
      id: string;
      /**
       * @description Name of the provider
       * @example Kiln
       */
      providerName: string;
      /**
       * @description An array of objects that includes chain descriptors and the corresponding fee percentages for validators supported by the provider
       * @example [
       *   {
       *     "chainDescriptor": "SOL",
       *     "feePercent": 5
       *   },
       *   {
       *     "chainDescriptor": "ETH",
       *     "feePercent": 7
       *   }
       * ]
       */
      validators: components["schemas"]["ValidatorDto"][];
      /**
       * @description URL to the validator's icon
       * @example https://static.fireblocks.io/staking/validators/kiln_console.png
       */
      iconUrl: string;
      /**
       * @description URL to the terms of service
       * @example https://www.kiln.fi/terms-and-conditions-for-fireblocks-customers
       */
      termsOfServiceUrl: string;
      /**
       * @description Indicates whether the terms of service are approved
       * @example true
       */
      isTermsOfServiceApproved: boolean;
    };
    ProvidersResponseDto: Record<string, never>;
  };
  responses: {
    /** @description Error Response */
    Error: {
      headers: {
        "X-Request-ID": components["headers"]["X-Request-ID"];
      };
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: never;
  requestBodies: {
    NewWallet?: {
      content: {
        "application/json": {
          /** @description the wallet's display name */
          name?: string;
        };
      };
    };
    WalletAddressProperties?: {
      content: {
        "application/json": {
          /** @description The wallet's address (or xpub) of the wallet */
          address?: string;
        };
      };
    };
  };
  headers: {
    /** @description Unique ID correlated to the API request. Please provide it in any support ticket you create or on Github issues related to Fireblocks SDKs */
    "X-Request-ID": string;
    /** @description Unique ID of the End-User wallet to the API request. Required for end-user wallet operations. */
    "X-End-User-Wallet-Id": string;
    /** @description URL representing a new request to this API endpoint to receive the next page of results. */
    "next-page": string;
    /** @description URL representing a new request to this API endpoint to receive the previous page of results. */
    "prev-page": string;
  };
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Create new asset deposit address
   * @description Creates a new deposit address for an asset of a vault account.
   */
  createVaultAccountAssetAddress: {
    parameters: {
      path: {
        /** @description The ID of the vault account to return */
        vaultAccountId: string;
        /** @description The ID of the asset */
        assetId: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @description (Optional) Attach a description to the new address */
          description?: string;
          /** @description Optional - Sets a customer reference ID */
          customerRefId?: string;
        };
      };
    };
    responses: {
      /** @description The created address */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "*/*": components["schemas"]["CreateAddressResponse"];
        };
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * List staking supported chains
   * @description Return an alphabetical list of supported chains.
   */
  getChains: {
    responses: {
      200: {
        content: {
          "application/json": string[];
        };
      };
    };
  };
  /**
   * Get chain-specific staking summary
   * @description Return chain-specific, staking-related information summary (e.g. epoch
   * details, lockup durations, estimated rewards, etc.).
   */
  getChainInfo: {
    parameters: {
      path: {
        /** @description The protocol identifier (e.g. "ETH"/"SOL") to use */
        chainDescriptor: "ETH" | "SOL" | "ETH_TEST3" | "SOL_TEST";
      };
    };
    responses: {
      /** @description Chain specific info summary was returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ChainInfoResponseDto"];
        };
      };
    };
  };
  /**
   * Execute a staking action
   * @description Perform a chain-specific staking action (e.g. stake, unstake, withdraw).
   */
  executeAction: {
    parameters: {
      path: {
        /** @description The protocol identifier (e.g. "ETH"/"SOL") to use */
        chainDescriptor: "ETH" | "SOL" | "ETH_TEST3" | "SOL_TEST";
        /** @description The operation that can be executed on a vault/position */
        actionId: "stake" | "unstake" | "withdraw";
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["StakeRequestDto"] | components["schemas"]["UnstakeRequestDto"] | components["schemas"]["WithdrawRequestDto"];
      };
    };
    responses: {
      /** @description A chain-specific action has been executed successfully on vault/position and is associated with 201 status code. */
      201: {
        content: {
          "application/json": components["schemas"]["StakeResponseDto"] | components["schemas"]["UnstakeResponseDto"] | components["schemas"]["WithdrawResponseDto"];
        };
      };
    };
  };
  /**
   * List staking positions details
   * @description Return detailed information on all staking positions, including the
   * staked amount, rewards, status and more.
   */
  getAllDelegations: {
    parameters: {
      query?: {
        /** @description Use "ETH" / "SOL" in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument. */
        chainDescriptor?: string;
      };
    };
    responses: {
      /** @description An array of position data was returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["DelegationDto"][];
        };
      };
    };
  };
  /**
   * Get staking summary details
   * @description Return a summary of all vaults, categorized by their status (active,
   * inactive), the total amounts staked and total rewards per-chain.
   */
  getSummary: {
    responses: {
      /** @description A summary for all vaults were returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["DelegationSummaryDto"];
        };
      };
    };
  };
  /**
   * Get staking summary details by vault
   * @description Return a summary for each vault, categorized by their status (active,
   * inactive), the total amounts staked and total rewards per-chain.
   */
  getSummaryByVault: {
    responses: {
      /** @description A summary for each vault were returned successfully */
      200: {
        content: {
          "application/json": {
            [key: string]: components["schemas"]["DelegationSummaryDto"];
          };
        };
      };
    };
  };
  /**
   * Get staking position details
   * @description Return detailed information on a staking position, including the staked
   * amount, rewards, status and more.
   */
  getDelegationById: {
    parameters: {
      path: {
        /** @description The unique identifier of the staking position */
        id: string;
      };
    };
    responses: {
      /** @description Position data was returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["DelegationDto"];
        };
      };
    };
  };
  /**
   * List staking providers details
   * @description Return information on all the available staking providers.
   */
  getProviders: {
    responses: {
      /** @description An array of supported providers was returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ProviderDto"][];
        };
      };
    };
  };
  /**
   * Approve staking terms of service
   * @description Approve the terms of service of the staking provider. This must be called before performing a staking action for the first
   * time with this provider.
   */
  approveTermsOfServiceByProviderId: {
    parameters: {
      path: {
        /** @description The unique identifier of the staking provider */
        providerId: "kiln" | "figment";
      };
    };
    responses: {
      /** @description The terms of service have been successfully approved and is associated with 201 status code. */
      201: {
        content: {
          "application/json": components["schemas"]["ProvidersResponseDto"];
        };
      };
    };
  };
  /**
   * List user groups
   * @description Get all user groups in the current workspace.
   */
  getUserGroups: {
    responses: {
      /** @description List of the users groups in the workspace */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "*/*": components["schemas"]["UserGroupsResponse"];
        };
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * Create a user group
   * @description Create a new user group.</br>
   */
  createUserGroup: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserGroupCreateRequest"];
      };
    };
    responses: {
      /** @description User group created and pending approval */
      201: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "*/*": components["schemas"]["CreateUserGroupResponse"];
        };
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * Get a user group by ID
   * @description Get a user group by ID.</br>
   */
  getUserGroup: {
    parameters: {
      path: {
        /** @description The ID of the users group */
        groupId: string;
      };
    };
    responses: {
      /** @description Users group */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "*/*": components["schemas"]["UserGroupResponse"];
        };
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * Update user group
   * @description Update a users group by ID.</br>
   *
   * **Note**:
   * - Please note that this endpoint is available only for API keys with Admin permissions.
   */
  updateUserGroup: {
    parameters: {
      path: {
        /** @description The ID of the users group */
        groupId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserGroupUpdateRequest"];
      };
    };
    responses: {
      /** @description Users group updated and the changes are pending approval */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "*/*": components["schemas"]["UserGroupCreateResponse"];
        };
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * Delete user group
   * @description Delete a user group by ID.</br>
   *
   * **Note**:
   * - Please note that this endpoint is available only for API keys with Admin permissions.
   */
  deleteUserGroup: {
    parameters: {
      path: {
        /** @description The ID of the users group */
        groupId: string;
      };
    };
    responses: {
      /** @description Request to delete users group submitted for approval */
      204: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * Get audit logs
   * @description Get audit logs
   */
  getAudits: {
    parameters: {
      query?: {
        /** @description The final time period to fetch audit logs (day/week) */
        timePeriod?: "DAY" | "WEEK";
        /** @description The next ID to start fetching audit logs from */
        cursor?: string;
      };
    };
    responses: {
      /** @description Audit logs from the requested time period onward */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      default: components["responses"]["Error"];
    };
  };
  /**
   * List all owned tokens (paginated)
   * @description Returns all tokens and their data in your workspace.
   */
  getOwnedNFTs: {
    parameters: {
      query?: {
        /** @description Blockchain descriptor filter */
        blockchainDescriptor?: "ETH" | "ETH_TEST3" | "ETH_TEST5" | "POLYGON" | "POLYGON_TEST_MUMBAI" | "XTZ" | "XTZ_TEST" | "BASECHAIN_ETH";
        /** @description A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType=END_USER_WALLET or ncwId is provided. */
        vaultAccountIds?: string;
        /** @description Tenant's Non-Custodial Wallet ID */
        ncwId?: string;
        /** @description A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType=VAULT_ACCOUNT or ncwId is not provided. */
        ncwAccountIds?: string;
        /** @description Wallet type, it can be `VAULT_ACCOUNT` or `END_USER_WALLET`. */
        walletType?: "VAULT_ACCOUNT" | "END_USER_WALLET";
        /** @description A comma separated list of NFT IDs. Up to 100 are allowed in a single request. */
        ids?: string;
        /** @description A comma separated list of collection IDs. Up to 100 are allowed in a single request. */
        collectionIds?: string;
        /** @description Page cursor to fetch */
        pageCursor?: string;
        /** @description Items per page (max 100) */
        pageSize?: number;
        /** @description Sort by param, it can be one param or a list of params separated by comma */
        sort?: ("ownershipLastUpdateTime" | "name" | "collection.name" | "blockchainDescriptor")[];
        /** @description Order direction, it can be `ASC` for ascending or `DESC` for descending */
        order?: "DESC" | "ASC";
        /** @description Token ownership status */
        status?: "LISTED" | "ARCHIVED";
        /** @description Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name. */
        search?: string;
        /** @description Token ownership spam status. */
        spam?: "true" | "false" | "all";
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": {
            paging?: components["schemas"]["Paging"];
            data?: components["schemas"]["TokenOwnershipResponse"][];
          };
        };
      };
    };
  };
  /**
   * Refresh vault account tokens
   * @description Updates all tokens and balances per blockchain and vault account.
   */
  refreshNFTOwnershipByVault: {
    parameters: {
      query: {
        /** @description Blockchain descriptor filter */
        blockchainDescriptor: "ETH" | "ETH_TEST3" | "ETH_TEST5" | "POLYGON" | "POLYGON_TEST_MUMBAI" | "BASECHAIN_ETH";
        /** @description Vault account filter */
        vaultAccountId: string;
      };
    };
    responses: {
      202: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * List all distinct owned tokens (paginated)
   * @description Returns all owned distinct tokens (for your tenant) and their data in your workspace.
   */
  listOwnedTokens: {
    parameters: {
      query?: {
        /** @description Tenant's Non-Custodial Wallet ID */
        ncwId?: string;
        /** @description Wallet type, it can be `VAULT_ACCOUNT` or `END_USER_WALLET` */
        walletType?: "VAULT_ACCOUNT" | "END_USER_WALLET";
        /** @description Page cursor to fetch */
        pageCursor?: string;
        /** @description Items per page (max 100) */
        pageSize?: number;
        /** @description Sort by param, it can be one param or a list of params separated by comma */
        sort?: "name"[];
        /** @description Order direction, it can be `ASC` for ascending or `DESC` for descending */
        order?: "DESC" | "ASC";
        /** @description Token ownership status */
        status?: "LISTED" | "ARCHIVED";
        /** @description Search owned tokens by token name */
        search?: string;
        /** @description Token ownership spam status. */
        spam?: "true" | "false" | "all";
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": {
            paging?: components["schemas"]["Paging"];
            data?: components["schemas"]["TokenResponse"][];
          };
        };
      };
    };
  };
  /**
   * List owned collections (paginated)
   * @description Returns all collections in your workspace
   */
  listOwnedCollections: {
    parameters: {
      query?: {
        /** @description Tenant's Non-Custodial Wallet ID */
        ncwId?: string;
        /** @description Wallet type, it can be `VAULT_ACCOUNT` or `END_USER_WALLET` */
        walletType?: "VAULT_ACCOUNT" | "END_USER_WALLET";
        /** @description Search owned collections. Possible criteria for search: collection name, collection contract address. */
        search?: string;
        /** @description Page cursor to fetch */
        pageCursor?: string;
        /** @description Items per page (max 100) */
        pageSize?: number;
        /** @description Sort by param, it can be one param or a list of params separated by comma */
        sort?: "name"[];
        /** @description Order direction, it can be `ASC` for ascending or `DESC` for descending */
        order?: "DESC" | "ASC";
        /** @description Token ownership status */
        status?: "LISTED" | "ARCHIVED";
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": {
            paging?: components["schemas"]["Paging"];
            data?: components["schemas"]["CollectionOwnershipResponse"][];
          };
        };
      };
    };
  };
  /**
   * List token data by ID
   * @description Returns the requested token data.
   */
  getNFT: {
    parameters: {
      path: {
        /**
         * @description NFT ID
         * @example NFT-abcdefabcdefabcdefabcdefabcdefabcdefabcd
         */
        id: string;
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": components["schemas"]["TokenResponse"];
        };
      };
    };
  };
  /**
   * Refresh token metadata
   * @description Updates the latest token metadata.
   */
  refreshNFTMetadata: {
    parameters: {
      path: {
        /**
         * @description NFT ID
         * @example NFT-abcdefabcdefabcdefabcdefabcdefabcdefabcd
         */
        id: string;
      };
    };
    responses: {
      202: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * List tokens by IDs
   * @description Returns the requested tokens data.
   */
  getNFTs: {
    parameters: {
      query: {
        /** @description A comma separated list of NFT IDs. Up to 100 are allowed in a single request. */
        ids: string;
        /** @description Page cursor to fetch */
        pageCursor?: string;
        /** @description Items per page (max 100) */
        pageSize?: number;
        /** @description Sort by param, it can be one param or a list of params separated by comma */
        sort?: ("collection.name" | "name" | "blockchainDescriptor")[];
        /** @description Order direction, it can be `ASC` for ascending or `DESC` for descending */
        order?: "DESC" | "ASC";
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": {
            paging?: components["schemas"]["Paging"];
            data?: components["schemas"]["TokenResponse"][];
          };
        };
      };
    };
  };
  /**
   * Update token ownership status
   * @description Updates token status for a tenant, in all tenant vaults.
   */
  updateTokenOwnershipStatus: {
    parameters: {
      path: {
        /**
         * @description NFT ID
         * @example NFT-abcdefabcdefabcdefabcdefabcdefabcdefabcd
         */
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTokenOwnershipStatusDto"];
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * Update tokens ownership status
   * @description Updates tokens status for a tenant, in all tenant vaults.
   */
  updateTokensOwnershipStatus: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokenOwnershipStatusUpdatePayload"][];
      };
    };
    responses: {
      /** @description All token statuses have been updated */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Invalid data sent */
      400: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description When ownership for token ID is not found */
      404: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * Update tokens ownership spam statuses
   * @description Updates tokens spam value for a tenant, in all tenant vaults.
   */
  updateTokensOwnershipSpam: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokenOwnershipSpamUpdatePayload"][];
      };
    };
    responses: {
      /** @description All token spam values have been updated */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Invalid data sent */
      400: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      401: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description When ownership for token ID is not found */
      404: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * List all open dApp connections
   * @description List all open dApp connections.
   */
  get: {
    parameters: {
      query?: {
        /** @description List order; ascending or descending. */
        order?: "ASC" | "DESC";
        /** @description Parsed filter object */
        filter?: {
          id?: string;
          userId?: string;
          vaultAccountId?: number;
          connectionMethod?: string;
          feeLevel?: string;
          appUrl?: string;
          appName?: string;
        };
        /** @description Property to sort dApp connections by. */
        sort?: "id" | "userId" | "vaultAccountId" | "createdAt" | "feeLevel" | "appUrl" | "appName";
        /** @description Amount of results to return in the next page. */
        pageSize?: number;
        /** @description Cursor to the next page */
        next?: string;
      };
    };
    responses: {
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": components["schemas"]["GetConnectionsResponse"];
        };
      };
      /** @description Query parameters were invalid */
      400: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Something went wrong */
      500: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * Create a new dApp connection
   * @description Create a new dApp connection.
   *
   * * Note: After this succeeds, make a request to `PUT /v1/connections/wc/{id}` (below) to approve or reject the new dApp connection.
   */
  create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateConnectionRequest"] | components["schemas"]["CreateNcwConnectionRequest"];
      };
    };
    responses: {
      /** @description dApp connection initiated successfully */
      201: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: {
          "application/json": components["schemas"]["CreateConnectionResponse"];
        };
      };
      /** @description Invalid data sent */
      400: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Something went wrong */
      500: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * Respond to a pending dApp connection request
   * @description Submit a response to *approve* or *reject* an initiated dApp connection.
   * * Note: This call is used to complete your `POST /v1/connections/wc/` request.
   *
   * After this succeeds, your new dApp connection is created and functioning.
   */
  submit: {
    parameters: {
      path: {
        /** @description The ID of the initiated dApp connection to approve. */
        id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RespondToConnectionRequest"];
      };
    };
    responses: {
      /** @description Connection submitted successfully */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Invalid data sent */
      400: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Connection not found */
      404: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Something went wrong */
      500: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * Remove an existing dApp connection
   * @description Remove an existing dApp connection
   */
  remove: {
    parameters: {
      path: {
        /** @description The ID of the existing dApp connection to remove. */
        id: string;
      };
    };
    responses: {
      /** @description Connection removed successfully */
      200: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Connection not found */
      404: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
      /** @description Something went wrong */
      500: {
        headers: {
          "X-Request-ID": components["headers"]["X-Request-ID"];
        };
        content: never;
      };
    };
  };
  /**
   * Validate Travel Rule Transaction
   * @description Validate Travel Rule transactions.
   *
   * Checks what beneficiary VASP details are required by your jurisdiction and the beneficiary's jurisdiction.
   *
   * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
   *
   * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
   */
  TravelRuleApiController_validate: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TravelRuleValidateTransactionRequest"];
      };
    };
    responses: {
      /** @description Transaction validated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TravelRuleValidateTransactionResponse"];
        };
      };
      /** @description Invalid request body */
      400: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Validate Full Travel Rule Transaction
   * @description Validate Full Travel Rule transactions.
   *
   * Checks for all required information on the originator and beneficiary VASPs.
   *
   * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
   *
   * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
   */
  TravelRuleApiController_validateFull: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TravelRuleValidateFullTransactionRequest"];
      };
    };
    responses: {
      /** @description Transaction validated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TravelRuleValidateTransactionResponse"];
        };
      };
      /** @description Invalid request body */
      400: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get VASP details
   * @description Get VASP Details.
   *
   * Returns information about a VASP that has the specified DID.
   *
   * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
   *
   * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
   */
  TravelRuleApiController_findVasp: {
    parameters: {
      query?: {
        /** @description CSV of fields to return (all, "blank" or see list of all field names below) */
        fields?: string;
      };
      path: {
        did: string;
      };
    };
    responses: {
      /** @description Transaction validated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TravelRuleVASP"];
        };
      };
      /** @description Invalid request body */
      400: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Get All VASPs
   * @description Get All VASPs.
   *
   * Returns a list of VASPs. VASPs can be searched and sorted and results are paginated.
   *
   * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
   *
   * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
   */
  TravelRuleApiController_findAllVasp: {
    parameters: {
      query?: {
        /** @description Field to order by */
        order?: string;
        /** @description Records per page */
        per_page?: number;
        /** @description Page number */
        page?: number;
        /** @description CSV of fields to return (all, "blank" or see list of all field names below) */
        fields?: string;
      };
    };
    responses: {
      /** @description Get all VASPs */
      200: {
        content: {
          "application/json": components["schemas"]["TravelRuleGetAllVASPsResponse"];
        };
      };
    };
  };
  /**
   * Add jsonDidKey to VASP details
   * @description Update VASP Details.
   *
   * Updates a VASP with the provided parameters. Use this endpoint to add your public jsonDIDkey generated by Notabene.
   *
   * **Note:** The reference content in this section documents the Travel Rule beta endpoint. The beta endpoint includes APIs that are currently in preview and aren't yet generally available.
   *
   * To enroll in the beta and enable this endpoint, contact your Fireblocks Customer Success Manager or send an email to [CSM@fireblocks.com](mailto:CSM@fireblocks.com).
   */
  TravelRuleApiController_updateVasp: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["TravelRuleUpdateVASPDetails"];
      };
    };
    responses: {
      /** @description VASP updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["TravelRuleUpdateVASPDetails"];
        };
      };
      /** @description Invalid request body */
      400: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Return status of One Time Address (OTA) enabled
   * @description Returns current One Time Address (OTA) status
   */
  getOtaStatus: {
    responses: {
      /** @description Current One Time Address (OTA) status */
      200: {
        content: {
          "application/json": {
            /** @description Current One Time Address (OTA) status */
            enabled?: boolean;
          };
        };
      };
      /** @description Configuration not found for tenant */
      404: {
        content: never;
      };
    };
  };
  /**
   * Enable or disable transactions to One Time Address (OTA)
   * @description Enable or disable transactions to One Time Address (OTA)
   */
  setOtaStatus: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Set true or false to enable or disable One Time Address (OTA) */
          enable?: boolean;
        };
      };
    };
    responses: {
      /** @description Successfully updated One Time Address (OTA) status */
      202: {
        content: never;
      };
      /** @description Bad request */
      400: {
        content: never;
      };
      /** @description Similar request already pending */
      409: {
        content: never;
      };
      /** @description Internal server error */
      500: {
        content: never;
      };
    };
  };
  /**
   * Return current workspace status
   * @description Returns the status of the current workspace.
   */
  getWorkspaceStatus: {
    responses: {
      /** @description Current workspace status */
      200: {
        content: {
          "application/json": {
            /** @description Current workspace status */
            status?: string;
          };
        };
      };
      /** @description Workspace not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Find Ticket
   * @description Finds Smart Transfer tickets that match the submitted criteria
   */
  searchTickets: {
    parameters: {
      query?: {
        /** @description Search string - counterparty name or asset or ticketId. Optional */
        q?: string;
        /**
         * @description Ticket statuses for Smart Transfer tickets. Optional
         * @example [
         *   "DRAFT",
         *   "OPEN"
         * ]
         */
        statuses?: ("DRAFT" | "PENDING_APPROVAL" | "OPEN" | "IN_SETTLEMENT" | "FULFILLED" | "EXPIRED" | "CANCELED")[];
        /** @description NetworkId that is used in the ticket	. Optional */
        networkId?: string;
        /** @description Filter created tickets by created by self or by others. Optional */
        createdByMe?: boolean;
        /** @description Lower bound of search range. Optional */
        expiresAfter?: string;
        /** @description Upper bound of search range. Optional */
        expiresBefore?: string;
        /** @description Type of transfer. ASYNC executes transfers as they are funded, ATOMIC executes all terms (legs) as one atomic transfer */
        type?: "ASYNC";
        /** @description External ref. ID that workspace can use to identify ticket outside of Fireblocks system. */
        externalRefId?: string;
        /** @description ID of the record after which to fetch $limit records */
        after?: string;
        /** @description Number of records to fetch. By default, it is 100 */
        limit?: number;
      };
    };
    responses: {
      /** @description Smart Transfer tickets were returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketFilteredResponseDto"] & {
            /**
             * @description Unique id of next filtered result
             * @example 006dc012-7ba7-474b-ada0-c12c24bf059e
             */
            after?: string;
            data?: components["schemas"]["SmartTransferTicketDto"][];
          };
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
    };
  };
  /**
   * Create Ticket
   * @description Creates new Smart Transfer ticket
   */
  createTicket: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferCreateTicketDto"];
      };
    };
    responses: {
      /** @description Smart Transfer ticket was created successfully */
      201: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Successfully created
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Search Tickets by ID
   * @description Find Smart Transfer ticket by id
   */
  findTicketById: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    responses: {
      /** @description Smart Transfer ticket returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Set expiration
   * @description Set expiration date on Smart Transfer ticket
   */
  setTicketExpiration: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferSetTicketExpirationDto"];
      };
    };
    responses: {
      /** @description Successfully set expiration date on Smart Transfer ticket */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Add external ref. ID
   * @description Set external id Smart Transfer ticket
   */
  setExternalRefId: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferSetTicketExternalIdDto"];
      };
    };
    responses: {
      /** @description Successfully set external id on Smart Transfer ticket */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Submit ticket
   * @description Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
   */
  submitTicket: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferSubmitTicketDto"];
      };
    };
    responses: {
      /** @description Successfully submitted Smart Transfer ticket */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Fund ticket manually
   * @description Manually fulfill ticket, in case when all terms (legs) are funded manually
   */
  fulfillTicket: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    responses: {
      /** @description Successfully fulfilled on Smart Transfer ticket */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Cancel Ticket
   * @description Cancel Smart Transfer ticket
   */
  cancelTicket: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    responses: {
      /** @description Smart Transfer ticket successfully canceled */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Search ticket by leg (term) ID
   * @description Creates new smart transfer ticket term (when the ticket status is DRAFT)
   */
  createTicketTerm: {
    parameters: {
      path: {
        ticketId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferCreateTicketTermDto"];
      };
    };
    responses: {
      /** @description Smart Transfer ticket term was created successfully */
      201: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketTermResponseDto"] & ({
            /**
             * @description Success message
             * @example Successfully created
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketTermDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /** @description Find Smart Transfer ticket term by id */
  findTicketTermById: {
    parameters: {
      path: {
        ticketId: string;
        termId: string;
      };
    };
    responses: {
      /** @description Smart Transfer ticket term returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketTermResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketTermDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Update ticket leg (term)
   * @description Update ticket term (when ticket status is DRAFT)
   */
  updateTicketTerm: {
    parameters: {
      path: {
        ticketId: string;
        termId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferUpdateTicketTermDto"];
      };
    };
    responses: {
      /** @description Smart Transfer ticket term updated successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketTermResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketTermDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Delete ticket leg (term)
   * @description Delete ticket term when ticket is in DRAFT status
   */
  removeTicketTerm: {
    parameters: {
      path: {
        ticketId: string;
        termId: string;
      };
    };
    responses: {
      /** @description Smart Transfer ticket term successfully removed */
      204: {
        content: never;
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
    };
  };
  /**
   * Define funding source
   * @description Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
   */
  fundTicketTerm: {
    parameters: {
      path: {
        ticketId: string;
        termId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferFundTermDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Funding source for ticket term successfully done */
      201: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketTermResponseDto"] & ({
            /**
             * @description Success message
             * @example Successfully created
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketTermDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Manually add term transaction
   * @description Manually set ticket term transaction
   */
  manuallyFundTicketTerm: {
    parameters: {
      path: {
        ticketId: string;
        termId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferManuallyFundTermDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Successfully manually set ticket term transaction */
      201: {
        content: {
          "application/json": components["schemas"]["SmartTransferTicketTermResponseDto"] & ({
            /**
             * @description Success message
             * @example Successfully created
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferTicketTermDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Not found */
      404: {
        content: {
          "application/json": components["schemas"]["SmartTransferNotFoundResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Get user group
   * @description Get Smart Transfer user groups
   */
  getSmartTransferUserGroups: {
    responses: {
      /** @description User group settings were returned successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SmartTransferUserGroupsResponseDto"] & ({
            /**
             * @description Success message
             * @example Success
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferUserGroupsDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
  /**
   * Set user group
   * @description Set Smart Transfer user group
   */
  setUserGroups: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SmartTransferSetUserGroupsDto"];
      };
    };
    responses: {
      /** @description User group settings were set successfully */
      201: {
        content: {
          "application/json": components["schemas"]["SmartTransferUserGroupsResponseDto"] & ({
            /**
             * @description Success message
             * @example Successfully created
             */
            message?: string | null;
            data?: components["schemas"]["SmartTransferUserGroupsDto"];
          });
        };
      };
      /** @description Unauthorized */
      403: {
        content: {
          "application/json": components["schemas"]["SmartTransferForbiddenResponse"];
        };
      };
      /** @description Bad Request */
      422: {
        content: {
          "application/json": components["schemas"]["SmartTransferBadRequestResponse"];
        };
      };
    };
  };
}
